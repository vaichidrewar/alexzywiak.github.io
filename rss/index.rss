<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Lingua Franca v2.0</title><description>JS and Web Engineering

If the Printing Press started the Renaissance, what can Javascript do?</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Sat, 24 Oct 2015 22:04:56 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Audio Visualiser Using D3</title><description>&lt;p&gt;D3 isn't just for squares with their pie charts and bar graphs anymore.  D3 can be totally Rock 'n Roll, man!  And to prove that to all you naysayers, we'll go ahead and build a sweet rockin' audio visualiser right in our browser.&lt;/p&gt;

&lt;p&gt;Check out the full code &lt;a href="https://github.com/alexzywiak/d3-Audio-Visualiser"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt;&lt;/p&gt;</description><link>http://localhost:2368/audio-visualiser-using-d3/</link><guid isPermaLink="false">a9984624-d736-432f-8dc4-d0d584f213c1</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Sat, 24 Oct 2015 21:43:46 GMT</pubDate><content:encoded>&lt;p&gt;D3 isn't just for squares with their pie charts and bar graphs anymore.  D3 can be totally Rock 'n Roll, man!  And to prove that to all you naysayers, we'll go ahead and build a sweet rockin' audio visualiser right in our browser.&lt;/p&gt;

&lt;p&gt;Check out the full code &lt;a href="https://github.com/alexzywiak/d3-Audio-Visualiser"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set Up index.html&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To get at some tunes, I'm going to use an HTML5 &lt;code&gt;audio&lt;/code&gt; tag with &lt;code&gt;id=player&lt;/code&gt; right in &lt;code&gt;index.html&lt;/code&gt; and just source the audio from a local file.  We can also tack on a &lt;code&gt;div&lt;/code&gt; with and &lt;code&gt;id="visualiser"&lt;/code&gt; for housing our visualiser.  Make sure to load up &lt;code&gt;d3&lt;/code&gt; and &lt;code&gt;jQuery&lt;/code&gt; while you're at it too!  &lt;/p&gt;

&lt;p&gt;If you're using a local audio file, you need to set up a localhost server and not just open the html file directly from your browser. Without a local server, you'll get a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS"&gt;CORS Access Restriction&lt;/a&gt; error when you try and run the visualiser!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Grabbing the AudioContext()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next, we're going create an &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext"&gt;AudioContext&lt;/a&gt; object, &lt;code&gt;context&lt;/code&gt;, so we can get at all those sweet frequencies.  &lt;/p&gt;

&lt;pre&gt;
$(function(){
    var context = new AudioContext();
});
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Create an AnalyserNode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We'll use the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createAnalyser"&gt;createAnalyser&lt;/a&gt; method on the &lt;code&gt;context&lt;/code&gt; object to create an &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode"&gt;AnalyserNode&lt;/a&gt;, &lt;code&gt;analyser&lt;/code&gt;, that will provide us with the real time frequency data we're looking for.&lt;/p&gt;

&lt;p&gt;Then we'll set what essentially amounts to the resolution of our &lt;code&gt;analyser&lt;/code&gt; object by setting its &lt;code&gt;fftSize&lt;/code&gt; property.  The &lt;code&gt;fftSize&lt;/code&gt; must be a power of 2 for some mathematically magical reason. The higher the resolution, the sharper the visualiser, but we'll end up animating animating exponentially more elements which can take a toll.  I've found that 512 to 1024 is a good balance between resolution and performance, but feel free to play around with it and see what you can do.  &lt;/p&gt;

&lt;p&gt;Finally, we'll create a &lt;code&gt;frequencyData&lt;/code&gt; array which is what we'll ultimately pass as data to d3 to power our visualisation.  &lt;/p&gt;

&lt;pre&gt;$(function() {
    var context = new AudioContext();
    var analyser = context.createAnalyser();
    analyser.fftSize = 64;
    var frequencyData = new Uint8Array(analyser.frequencyBinCount);
});
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Connect Our Analyser&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next up, we have to route our tunes through our &lt;code&gt;analyser&lt;/code&gt;.  Using &lt;code&gt;jQuery&lt;/code&gt;, we're going to grab the &lt;code&gt;audio&lt;/code&gt; HTML tag we're listening to.  We'll pass the &lt;code&gt;audio&lt;/code&gt; tag element to the &lt;code&gt;context.createMediaElementSource&lt;/code&gt; method  and set it as our &lt;code&gt;source&lt;/code&gt;.  That will allow us to get the frequency data.  We'll connect our &lt;code&gt;analyser&lt;/code&gt; to the audio &lt;code&gt;source&lt;/code&gt;, and then finally, connect our &lt;code&gt;analyser&lt;/code&gt; to &lt;code&gt;context.destination&lt;/code&gt;, in normal parlance, you speakers, so that we can once again hear the music. Check out the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode"&gt;AnaylserNode&lt;/a&gt; and &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext"&gt;AudioContext&lt;/a&gt; docs for more info on what ever the hell's going on here.&lt;/p&gt;

&lt;pre&gt;$("#player").bind('canplay', function() {
        var source = context.createMediaElementSource(this);
        source.connect(analyser);
        analyser.connect(context.destination);
    });
&lt;/pre&gt;

&lt;p&gt;Our &lt;code&gt;analyser&lt;/code&gt; is all wired up to report back to us with real time info on what's playing.  To get an updated array of the frequency values, all we need to do is run &lt;code&gt;analyser.getByteFrequencyData(frequencyData)&lt;/code&gt; and the &lt;code&gt;frequencyData&lt;/code&gt; array we declared earlier, will get updated. &lt;/p&gt;

&lt;p&gt;To check it out, run a little &lt;code&gt;console.log&lt;/code&gt; action.  &lt;/p&gt;

&lt;pre&gt;setInterval(function(){
  analyser.getByteFrequencyData(frequencyData);
  console.log(frequencyData)
}, 500);
&lt;/pre&gt;

&lt;p&gt;Once the music starts playing, you should see all kinds of numbers dancing around in the console.  Unfortunately, that's only exciting for us geeky dev types.  We'll have to up our game to get the groupies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Visualise It&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A constantly changing array of numbers!  D3 is all over that!  Let's set up an &lt;code&gt;svg&lt;/code&gt; element to hold our sweet visuals.&lt;/p&gt;

&lt;pre&gt;var width = 800,
        height = 600,
        barPadding = 0;

    var svg = d3.select('#visualiser')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
&lt;/pre&gt;

&lt;p&gt;We'll create an ever so basic bar graph in d3 bound to the frequency information.  This visualiser is as basic as they get, but d3 has so much awesomeness, your imagination is the limit.  &lt;/p&gt;

&lt;p&gt;Since we're going to be continuously updating our graph with the real time frequency data, we'll wrap drawing the graph in an &lt;code&gt;update&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;
    var update = function(data) {

        rect = svg.selectAll('rect')
            .data(data)

        rect.enter().append('rect');

        rect.attr('width', function() {
                return width / data.length - barPadding;
            })
            .attr('height', function(d) {
                return d * 1000;
            })
            .attr('x', function(d, i) {
                return i * width / data.length;
            })
            .attr('y', function(d) {
                return height - d;
            })
            .attr('fill', function(d) {
                return "rgb(0, 0, " + (d * 10) + ")";
            });
    };

update(frequencyData);
&lt;/pre&gt;

&lt;p&gt;Lastly, we'll make use of &lt;code&gt;d3.timer()&lt;/code&gt; to run continuously run our animation.  We also have to make sure and call &lt;code&gt;analyser.getByteFrequencyData(frequencyData)&lt;/code&gt; so that we get real time audio data.  &lt;/p&gt;

&lt;pre&gt;d3.timer(function() {
        analyser.getByteFrequencyData(frequencyData);
        update(frequencyData);
    });
&lt;/pre&gt;

&lt;p&gt;And now, you only have one more question to answer.  Are you ready to Rock?  &lt;/p&gt;

&lt;p&gt;I'm such a nerd...&lt;/p&gt;

&lt;p&gt;Full code up on &lt;a href="https://github.com/alexzywiak/d3-Audio-Visualiser"&gt;Git&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title>Animating Keyboard Events in d3</title><description>&lt;p&gt;d3 can do some serious data, but it is also a pretty sweet tool to animate user input.  &lt;/p&gt;

&lt;p&gt;I'll give a little run through here on how to capture keyboard events to run a little animation.  Well, to drive a little triangle around the screen using the arrow keys. &lt;br&gt;
&lt;br&gt; &lt;br&gt;
&lt;strong&gt;Set&lt;/strong&gt;&lt;/p&gt;</description><link>http://localhost:2368/animating-keyboard-events-in-d3/</link><guid isPermaLink="false">764c6964-9c31-4a36-9e44-c95b4aec3a95</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Sun, 18 Oct 2015 23:24:20 GMT</pubDate><content:encoded>&lt;p&gt;d3 can do some serious data, but it is also a pretty sweet tool to animate user input.  &lt;/p&gt;

&lt;p&gt;I'll give a little run through here on how to capture keyboard events to run a little animation.  Well, to drive a little triangle around the screen using the arrow keys. &lt;br&gt;
&lt;br&gt; &lt;br&gt;
&lt;strong&gt;Set Up SVG&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First, we need an element to hold our d3 goodness, so we'll append an &lt;code&gt;svg&lt;/code&gt; element onto the body and set its default dimensions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var svg = d3.select('body')
  .append('svg')
  .attr('height', 600)
  .attr('width', 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we'll add in a triangle polygon that will eventually be controlled by the arrow keys.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var triangle = svg.append('polygon')
  .attr('fill', 'yellow')
  .attr('stroke', 'blue')
  .attr('stroke-width', 2)
  .attr('points', "0, 30 0, 0 40, 15 ");
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have a little yellow triangle, but it's stuck way up in the corner.  Let's start it out in the center of the svg element instead.  To make storing and referencing the triangles position easier, we'll add some relevant properties to the &lt;code&gt;triangle&lt;/code&gt; object using &lt;code&gt;underscore&lt;/code&gt;'s &lt;code&gt;extend&lt;/code&gt; method.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.extend(triangle, {
  x: 500,
  y: 300,
  angle: 0,
  _speed: 10
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sets the triangle's &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values &lt;code&gt;500&lt;/code&gt; and &lt;code&gt;300&lt;/code&gt; respectively, or what is the middle of our current svg.  These coordinates are meaningless properties until we actually place the triangle using the &lt;code&gt;transform&lt;/code&gt; attribute provided to us by d3.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
triangle.attr('transform', function() {
  return 'translate(' + triangle.x + ',' + triangle.y + ')';
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, we have a pretty little triangle that is still tragically static.  Let's get our little tripartite friend moving! &lt;br&gt;
&lt;br&gt; &lt;br&gt;
&lt;strong&gt;Catching Key Events&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The first thing we're going to do to get some movement, is to set up capturing keyboard events.  d3 has a very straightforward method to do so.  Unfortunately, it is only useful for catching single keys being pressed at a time.  We're going to expand it a little so we can react to multiple keys pressed at once, in this case to model diagonal movement.&lt;/p&gt;

&lt;p&gt;To do so, we're going to put watchers on both the &lt;code&gt;keydown&lt;/code&gt; and &lt;code&gt;keyup&lt;/code&gt; events.  To store which keys are being pressed, we'll create an object &lt;code&gt;keyPressed&lt;/code&gt;.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var keyPressed = {};

d3.select('body')
  .on('keydown', function() {
    keyPressed[d3.event.keyIdentifier] = true;
  })
  .on('keyup', function() {
    keyPressed[d3.event.keyIdentifier] = false;
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this in place, every &lt;code&gt;keydown&lt;/code&gt; event will store that event's &lt;code&gt;keyIdentifier&lt;/code&gt; as the property name in the &lt;code&gt;keyPressed&lt;/code&gt; object and set its value to &lt;code&gt;true&lt;/code&gt;.  On a keydown event, the corresponding &lt;code&gt;keyIdentifier&lt;/code&gt; will reset it to &lt;code&gt;false&lt;/code&gt;.  With this setup, we can monitor all keys that are being pressed simultaneously. &lt;br&gt;
&lt;br&gt; &lt;br&gt;
&lt;strong&gt;Gettin' Our Move On&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So far we have a stationary triangle and some code that tells me what buttons I'm pushing. Great.  Not too exciting yet, but we'll get there, I promise.&lt;/p&gt;

&lt;p&gt;In order to set and manipulate our triangle's position, we're going to use the &lt;code&gt;transform/translate&lt;/code&gt; property of svg &lt;code&gt;polygons&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We'll create a &lt;code&gt;moveTriangle&lt;/code&gt; function to monitor our keypresses and to change the triangle's &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties to appropriately respond to the arrow keys.  &lt;code&gt;moveTriangle&lt;/code&gt; will reference the &lt;code&gt;keyPressed&lt;/code&gt; object to find out what keys are currently being pressed.  We'll also add a helper function &lt;code&gt;isInBounds&lt;/code&gt; to make sure no one is flying off the screen.  (You may wonder how we're going to reference &lt;code&gt;keyPressed&lt;/code&gt; in real time, but don't worry, d3 will come through in the end.)  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var moveTriangle = function() {

  var x = triangle.x;
  var y = triangle.y;

  if (keyPressed['Left']) {
    triangle.x = isInBounds(x - triangle._speed, 'width');
  }
  if (keyPressed['Up']) {
    triangle.y = isInBounds(y - triangle._speed, 'height');
  }
  if (keyPressed['Right']) {
    triangle.x = isInBounds(x + triangle._speed, 'width');
  }
  if (keyPressed['Down']) {
    triangle.y = isInBounds(y + triangle._speed, 'height');
  }
  triangle.move(x, y);
};

var isInBounds = function(n, dimension) {
  if (n &lt; 0) {
    return 0;
  } else if (n &gt; svg.attr(dimension)) {
    return svg.attr(dimension);
  } else {
    return n;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;moveTriangle&lt;/code&gt; effectively translates the arrow keys into new &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinates on the &lt;code&gt;triangle&lt;/code&gt; object, but again, we need to make use of &lt;code&gt;translate&lt;/code&gt; to actually move the triangle on the screen.  On the last line in &lt;code&gt;moveTriangle&lt;/code&gt; we reference a &lt;code&gt;move&lt;/code&gt; method on triangle.  Let's write that now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;triangle.move = function(x, y) {
  var dx = this.x - x;
  var dy = this.y - y;
  if (dx !== 0 || dy !== 0) {
    this.angle = 360 * (Math.atan2(dy, dx) / (Math.PI * 2));
  }
  triangle.attr('transform', function() {
    return 'rotate(' + [this.angle, this.x + 20, this.y + 15].join() + ')' +
      'translate(' + [this.x, this.y].join() + ')';
  }.bind(this));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under the fancy trigonometry, this function's main purpose is to call d3's &lt;code&gt;attr&lt;/code&gt; method on our &lt;code&gt;triangle&lt;/code&gt; object and relay the appropriate position to the &lt;code&gt;translate&lt;/code&gt; attribute.  We also run some fancy math to keep track of where our triangle is pointing just to keep things interesting. &lt;br&gt;
&lt;br&gt; &lt;br&gt;
&lt;strong&gt;Animate!&lt;/strong&gt; &lt;br&gt;
All this code is well and good, but it needs a final line of d3 magic to work.  As it stands, we keep track of what keys are pressed, but the &lt;code&gt;moveTriangle&lt;/code&gt; function isn't being called on! How will it know when the arrows are being pressed?  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d3.timer(moveTriangle);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toss that little line in there, and have fun!  d3's &lt;code&gt;timer&lt;/code&gt; method will tie our &lt;code&gt;moveTriangle&lt;/code&gt; function smoothly into the internal gears and cogs of it's time keeping mechanisms.  It will now be run continuously and keep referencing the &lt;code&gt;keyPressed&lt;/code&gt; object for an updated look at which keys the user is pressing and then appropriately telling our little yellow triangle where to go.&lt;/p&gt;</content:encoded></item><item><title>Setting Up Sublime Linter in Sublime Text 3</title><description>&lt;p&gt;Syntax errors suck.  They're pretty much like the worst.  We've all been there.  You have a moment of transcendental inspiration, you hack out some of the most erudite, lucid code you've ever created, hit save, and wait for the fruits of your flawless genius to unfold.  But then everything comes&lt;/p&gt;</description><link>http://localhost:2368/setting-up-sublime-linter-in-sublime-text-3/</link><guid isPermaLink="false">42911685-2cd7-4bc9-bc52-06e8bd4289cc</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Thu, 15 Oct 2015 17:09:18 GMT</pubDate><content:encoded>&lt;p&gt;Syntax errors suck.  They're pretty much like the worst.  We've all been there.  You have a moment of transcendental inspiration, you hack out some of the most erudite, lucid code you've ever created, hit save, and wait for the fruits of your flawless genius to unfold.  But then everything comes crashing down around you like a flaming house of cards hitting a fan, or something roughly equivalent.  The culprit?  Some misplaced comma on line 238 that takes you an hour and half to find.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enter Sublime Linter&lt;/strong&gt;.  Catch those malevolent little errors before they illicit any hair pulling.  &lt;/p&gt;

&lt;p&gt;Installation is simple, but has a few steps.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step One - Install SublimeLinter Package&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you have Package Manager installed on Sublime &lt;code&gt;cmd + shift + p&lt;/code&gt; and open that sucker up.  &lt;/p&gt;

&lt;p&gt;(If you don't, time to get out from under the Subliminal Rock &lt;a src="https://packagecontrol.io/"&gt;packagemanager.io&lt;/a&gt;)  &lt;/p&gt;

&lt;p&gt;Got to: &lt;code&gt;Package Control: Install Package --&gt; SublimeLinter&lt;/code&gt; and install it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step Two - Install Linters&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SublimeLinter alone, as the Package Control Messages page emphatically states, doesn't do anything.  In order to get at the lintfree goodness that is clean code, you have to install language specific linters first.&lt;/p&gt;

&lt;p&gt;In this case, we'll go ahead and install jshint to act as our linter.&lt;/p&gt;

&lt;p&gt;Back in package manager: &lt;code&gt;Package Control: Install Package --&gt; SublimeLinter-jshint&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;On the new Package Control Messages Page, at the bottom you will have a new section referring specifically to jshint.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step Three - Install jshint node package&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We're getting there, one more step to get this working!  jshint makes use of a Node package that must be installed separately on your machine.&lt;/p&gt;

&lt;p&gt;If you have &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; on your computer already, run the following command to install jshint globally so SublimeLinter can get at it.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install -g jshint&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you have no idea what this node stuff is all about, check out more detailed instructions here. &lt;br&gt;
&lt;a src="https://github.com/SublimeLinter/SublimeLinter-jshint"&gt;https://github.com/SublimeLinter/SublimeLinter-jshint&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At this point you should be up and running!  Head into a .js file in Sublime, type out the most heinous syntax errors you can think of, and bask in their yellow outlined ostracism!  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step Four - Changing JShint Configuration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So you're psyched, your totally free of unwanted lintyness, but your JSHint isn't playing nice with jQuery.  It especially doesn't like '$' which, it correctly although rather narrowly, tells you is not defined.  &lt;/p&gt;

&lt;p&gt;To change the linting configuration, you need to add a file called &lt;code&gt;.jshintrc&lt;/code&gt; into your project folder. &lt;/p&gt;

&lt;p&gt;The file allows you to use object notation to customize the way Jshint works.  For example, to stop any errors on the jQuery '$' object, enter  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{  
  "globals": {
      "$": false
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For your reference, here is a full list of options that can be modified in the &lt;code&gt;.jshintrc&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;&lt;a src="http://jshint.com/docs/options/"&gt;http://jshint.com/docs/options/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>In a .bind about how to .apply .call?</title><description>&lt;p&gt;You can really tell the True JS Ninjas from the Codeacademicians when it comes to proper use of &lt;code&gt;.call()&lt;/code&gt;, &lt;code&gt;.apply()&lt;/code&gt;, and &lt;code&gt;.bind()&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;All three are methods available on the JS &lt;code&gt;function&lt;/code&gt; prototype and are used to &lt;strong&gt; reassign the value of &lt;code&gt;this&lt;/code&gt; within the calling function.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The three functions differ in&lt;/p&gt;</description><link>http://localhost:2368/in-a-bind-about-how-apply-call/</link><guid isPermaLink="false">e806b939-3b5f-4e75-9843-96ae903a86e1</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Mon, 12 Oct 2015 00:08:39 GMT</pubDate><content:encoded>&lt;p&gt;You can really tell the True JS Ninjas from the Codeacademicians when it comes to proper use of &lt;code&gt;.call()&lt;/code&gt;, &lt;code&gt;.apply()&lt;/code&gt;, and &lt;code&gt;.bind()&lt;/code&gt;.  &lt;/p&gt;

&lt;p&gt;All three are methods available on the JS &lt;code&gt;function&lt;/code&gt; prototype and are used to &lt;strong&gt; reassign the value of &lt;code&gt;this&lt;/code&gt; within the calling function.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The three functions differ in how they accept arguments, in the case of &lt;code&gt;.call()&lt;/code&gt; and &lt;code&gt;.apply()&lt;/code&gt;, and whether they invoke the function or return a new function, as in the case of &lt;code&gt;.bind()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As with all things code, it is much easier to explain in an example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var homer = {
    name: 'Homer',
    catchPhrase : 'D\'Oh!',
    activity : function(){
      console.log('Mmmm ' + this.name + ' likes Duff!');
    }
};

var barney = {
    name: 'Barney',
    catchPhrase : 'Buuuuurp!'
};

var speak = function(greeting1, greeting2){
    greeting = greeting1 + greeting2 || '';
    console.log(greeting + this.catchPhrase);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, Homer and Barney are gregarious guys.  They need to be able to speak!  But, oh no!  &lt;code&gt;speak()&lt;/code&gt; is not a native function to either of them!  &lt;code&gt;this.catchphrase&lt;/code&gt; is doomed to be &lt;code&gt;undefined!&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;speak() ==&gt; undefined&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;.call()&lt;/strong&gt; &lt;br&gt;
&lt;code&gt;.call(context, arg1, arg2...)&lt;/code&gt; &lt;br&gt;
The first argument that &lt;code&gt;.call()&lt;/code&gt; accepts will be what is bound to the &lt;code&gt;this&lt;/code&gt; keyword inside the function.&lt;/p&gt;

&lt;p&gt;Here, &lt;code&gt;homer&lt;/code&gt; is passed as the first argument to &lt;code&gt;.call()&lt;/code&gt; and so &lt;code&gt;homer&lt;/code&gt; becomes bound as &lt;code&gt;this&lt;/code&gt; within the &lt;code&gt;speak()&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;speak.call(homer) ==&gt; "D'Oh!"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subsequent arguments can be passed into &lt;code&gt;.call()&lt;/code&gt; and they will be passed to the calling function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;speak.call(homer, 'Hi, Marge! ', ' Hi, Barney! ') ==&gt; "Hi, Marge! Hi, Barney! D'Oh!"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;.apply()&lt;/strong&gt; &lt;br&gt;
&lt;code&gt;.apply(context, [arg list])&lt;/code&gt; &lt;br&gt;
&lt;code&gt;.apply()&lt;/code&gt; works in almost the same way as &lt;code&gt;.call()&lt;/code&gt;.  The only difference between the two is the type of arguments they accept.  &lt;code&gt;.apply()&lt;/code&gt; will accept a single array or array-like object containing all of the arguments to be passed, whereas &lt;code&gt;.call()&lt;/code&gt; accepts a comma separated list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;speak.apply(barney, ['Hi Moe! ', 'Hey Homer!']); ==&gt; "Hi Moe! Hey Homer! Buuuuurp!"&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how the values in the array object passed into &lt;code&gt;.apply()&lt;/code&gt; will be passed in order as the parameters to the calling function.&lt;/p&gt;

&lt;p&gt;The real place these function methods shine through is you can call non-native methods bound to different objects without having to set them as properties on those objects.&lt;/p&gt;

&lt;p&gt;Homer loves drinking beer.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var homer = {
    name: 'Homer',
    catchPhrase : 'D\'Oh!',
    drinkBeer : function(){
      console.log('Mmmm ' + this.name + ' likes Duff!');
    }
};

homer.drinkBeer(); ===&gt; "Mmmm Homer likes Duff!"&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But Barney loves drinking beer, too!  But he doesn't have a &lt;code&gt;.drinkBeer()&lt;/code&gt; method. How can Homer share his favorite activity?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
homer.drinkBeer.call(barney); ===&gt; "Mmmm Barney likes Duff!"&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same function is called, &lt;code&gt;homer.drinkBeer()&lt;/code&gt;, but by using &lt;code&gt;.call()&lt;/code&gt; we can change the context to bind &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;barney&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.bind()&lt;/strong&gt; &lt;br&gt;
&lt;code&gt;.bind(context, arg1, arg2....)&lt;/code&gt; &lt;br&gt;
&lt;code&gt;.bind()&lt;/code&gt; has a similar function, but works in a fundamentally different way.  &lt;code&gt;.apply()&lt;/code&gt; and &lt;code&gt;.call()&lt;/code&gt; both &lt;em&gt;invoke&lt;/em&gt; the calling function when they are called.  &lt;code&gt;.bind()&lt;/code&gt; &lt;strong&gt;returns a function reference&lt;/strong&gt; with the &lt;code&gt;this&lt;/code&gt; keyword properly bound.&lt;/p&gt;

&lt;p&gt;When Homer and Barney are at Moe's Tavern, they rarely stop at one.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var getDrunk = function(cb){
    for(var i = 0; i &lt; 6; i++){
        cb();
    }
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.getDrunk()&lt;/code&gt; accepts a callback and runs it six times.  Sounds like a good way to &lt;code&gt;.drinkBeer()&lt;/code&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getDrunk(homer.drinkBeer); ===&gt; "Mmmm Homer likes Duff!"...x6
getDrunk(homer.drinkBeer.call(barney)); ===&gt; undefined...x6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.call()&lt;/code&gt; and &lt;code&gt;.apply()&lt;/code&gt; invoked the function when they are called and don't return anything so they cannot be used when a function reference is required.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.bind()&lt;/code&gt; will return a reference to a new function with the&lt;code&gt;this&lt;/code&gt; keyword context properly bound.  It accepts additional arguments the same way as &lt;code&gt;.call()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Huh... &lt;br&gt;
&lt;code&gt;fn.bind(context, arg1, arg2....)&lt;/code&gt; will return the following function.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function(){
  return fn.call(context, arg1, arg2....);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So Barney can get cranked at Moe's too!  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getDrunk(homer.drinkBeer.bind(barney); ===&gt; "Mmmm Barney likes Duff!"...x6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.bind()&lt;/code&gt; acts as a closure, so it will create a new function and return a reference to it.  If you need to use that bound function multiple times, you can save it as a variable with all the properly bound &lt;code&gt;this&lt;/code&gt; goodness you could want.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var drinkBeerBarney = homer.drinkBeer.bind(barney);

typeof drinkBeerBarney ===&gt; 'function'

getDrunk(drinkBeerBarney); ===&gt; "Mmmm Barney likes Duff!"...x6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So hopefully that will move you on your way toward some JS function binding context-fu mastery.  At least it should give you a hankering for a beer, so my job is done.&lt;/p&gt;</content:encoded></item><item><title>Setting Tab/Space Standards in Sublime Text</title><description>&lt;p&gt;An analogy for you; Properly indented code is to mixed spaces and tabs as  Oxford's English Dictionary is to a horde of tasmanian devils in a swimming pool full of scrabble letters.  &lt;/p&gt;

&lt;p&gt;Yeah, properly indenting code is important.  It may look pretty in your editor, but on git or elsewhere&lt;/p&gt;</description><link>http://localhost:2368/setting-tab-space-standards-in-sublime-text/</link><guid isPermaLink="false">3e378150-39fe-414c-8a74-d32902fc2473</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Fri, 09 Oct 2015 21:13:33 GMT</pubDate><content:encoded>&lt;p&gt;An analogy for you; Properly indented code is to mixed spaces and tabs as  Oxford's English Dictionary is to a horde of tasmanian devils in a swimming pool full of scrabble letters.  &lt;/p&gt;

&lt;p&gt;Yeah, properly indenting code is important.  It may look pretty in your editor, but on git or elsewhere out in the real world, it could look like a tangled mess if you're not consistent.&lt;/p&gt;

&lt;p&gt;I'm going to cover how to change the default tab settings in Sublime.&lt;/p&gt;

&lt;p&gt;To get going, navigate over to: &lt;br&gt;
&lt;strong&gt;Sublime Text &gt; Preferences &gt; Settings - User&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Settings in Sublime are controlled using JSON notation.  &lt;/p&gt;

&lt;p&gt;While playing around in there, you can modify your tab settings with the following commands.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;"tab_size":Number&lt;/code&gt; &lt;br&gt;
Set it equal to the number of spaces per tab. &lt;br&gt;
Default value is 4.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;"translateTabsToSpaces":true/false&lt;/code&gt; &lt;br&gt;
If true, all tab keypresses will be recorded as the number of spaces specified in "tab_size" instead of a tab character.  Visually, the tab key will function the same, but there will be no tab characters whatsoever. &lt;br&gt;
Default value is false.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;"useTabStops":true/false&lt;/code&gt; &lt;br&gt;
If true, will set tab and backspace to add/delete up to the closest tab stop regardless of whether it's a tab character or a series of spaces. &lt;br&gt;
Defaults to true.&lt;/p&gt;

&lt;p&gt;Here is an example of setting all tabs to be recorded as two spaces as per HR style guide.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  "tab_size":2,
  "translateTabsToSpaces":true,
  "useTabStops":true
}&lt;/code&gt;&lt;/pre&gt;</content:encoded></item></channel></rss>