<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Lingua Franca - Javascript Language of the Web</title><description>The Printing Press started the Renaissance, what the hell is the Internet Going to do?</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Wed, 24 Feb 2016 02:38:06 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Using JWTs with Express and Angular</title><description>&lt;p&gt;With the advent of Single Page Applications, server side authentication doesn't quite cut it anymore.  JSON Web Tokens are a handy way to bridge the gap.&lt;/p&gt;

&lt;p&gt;At a high level overview, a JWT is an encoded bundle of JSON data, generally representing a user, signed and encoded by the server.&lt;/p&gt;</description><link>http://localhost:2368/using-jwts-with-bookshelf-and-angular/</link><guid isPermaLink="false">ce3d207d-697e-4f58-ae0b-92a9ed0bdfd6</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Thu, 18 Feb 2016 01:17:58 GMT</pubDate><content:encoded>&lt;p&gt;With the advent of Single Page Applications, server side authentication doesn't quite cut it anymore.  JSON Web Tokens are a handy way to bridge the gap.&lt;/p&gt;

&lt;p&gt;At a high level overview, a JWT is an encoded bundle of JSON data, generally representing a user, signed and encoded by the server.  Each JWT is usually composed of three parts.  A header, a payload, and a signature.  The header contains relevant information regarding the encoding type as well as identifying the JSON as a web token.  The payload can be whatever JSON data you choose, generally user information.  The signature is built off a 'secret' key stored on the server.  The JWT holds onto this signature and it can be checked to make sure the JWT is the real deal.  All this is regular, old JSON, that is then encoded and sent down to the client.  Read more about JWTs &lt;a href="https://jwt.io/introduction/"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The general use case for JWTs is for user authentication.  On a successful login, the JWT is sent down from the server and is stored on the client.  Whenever the client wishes to take a restricted action on the server, the JWT is sent up with the request.  The JWT is verified on the server, and if everything passes, the client is allowed to take the requested action.&lt;/p&gt;

&lt;p&gt;The beauty of the JWT is is accessible on the client, which makes it useful for SPAs.  The server only needs to be queried to get a new token or to take serve side actions. The client can block certain frontend routes be checking if a JWT is present or not.  In addition, the JWT is also encoded JSON, so its data can be referenced to grab user information without having to query the server again.&lt;/p&gt;

&lt;p&gt;In this post, I'll walk through the relevant parts of a JWT implementation I put through on a recent project.  The full project made use of &lt;strong&gt;Angular&lt;/strong&gt; on the frontend, &lt;strong&gt;Express&lt;/strong&gt; as a server framework and &lt;strong&gt;Bookshelf&lt;/strong&gt; as my database ORM.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JWTs on the Server&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I opted to put all the JWT logic into an &lt;code&gt;authController.js&lt;/code&gt; file and export it as a module.  I used the &lt;a href="https://github.com/auth0/node-jsonwebtoken"&gt;jsonwebtoken&lt;/a&gt; npm module for handling the nitty gritty as well as &lt;code&gt;lodash&lt;/code&gt; for some data manipulation.&lt;/p&gt;

&lt;p&gt;Importing the secret is also a crucial part.  The secret is a string of my creation which is used to build the JWT's signature and is essential when encoding or decoding a token.  I hid my secret away in a nicely gitignored module to keep it private and then I export it wherever necessary throughout the server.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// authController.js

var jwt = require('jsonwebtoken');  
var _ = require('lodash');

var secret = require('../config/auth.config').secret;

module.exports = {  
  authorize: function(req, res, next){
    //...
  },
  createToken: function(user) {
    //...
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two functions being exposed in &lt;code&gt;authController.js&lt;/code&gt;.  The first, &lt;code&gt;createToken&lt;/code&gt; does just that.  Given a user object, in this case the user object is user data from the database, it will create and return a signed JWT token with an expiration.  Tokens are easily decoded, so never send sensitive information with them!  At minimum, omit the password.  More on JWT security later.  This token will be sent down to the client to be stored and attached to later requests.  Check out more about how to use the JWT module &lt;a href="https://github.com/auth0/node-jsonwebtoken"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  ...
  createToken: function(user) {
    return jwt.sign(_.omit(user.attributes, 'password'), secret, {
      expiresIn: 24 * 60 * 60
    });
  }
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;authenticate&lt;/code&gt; function is where the server side magic happens.  &lt;code&gt;authenticate&lt;/code&gt; acts as an Express middleware function and can be easily placed on any routes you need to restrict access to.&lt;/p&gt;

&lt;p&gt;The function has two main jobs.  First, to check if a JWT exists on the &lt;code&gt;request&lt;/code&gt; object passing through the middleware, and second to verify against my app's secret that it has a valid signature.  If everything passes, the token is authentic, the &lt;code&gt;next()&lt;/code&gt; function is called, and the &lt;code&gt;request&lt;/code&gt; passes on to the next middleware.  If the JWT is not found or is invalid, an error response is sent to the client, and subsequent server actions are denied.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  ...
  authorize: function(req, res, next) {
    var token = req.body.token || req.query.token || req.headers['x-access-token'];
    if (token) {
      jwt.verify(token, secret, function(err, decoded) {
        if (err) {
          console.error(err);
          return res.status(403).send('error authorizing token');
        } else {
          req.token = decoded;
          return next();
        }
      });
    } else {
      console.error('not authorized');
      return res.sendStatus(403);
    }
  },
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step, is to place the &lt;code&gt;authenticate&lt;/code&gt; middleware function on any restricted routes.  This will force any requests going through that route to pass authentication in order complete any actions.  Express' &lt;code&gt;.get&lt;/code&gt; and &lt;code&gt;.post&lt;/code&gt; convenience functions take any number of middleware callback functions as arguments, so we can just stick our &lt;code&gt;authenticate&lt;/code&gt; function as the first callback argument, and the actual action as the second callback function.&lt;/p&gt;

&lt;p&gt;Here's an example from my &lt;code&gt;userRouter.js&lt;/code&gt; file.  It shows an unrestricted and restricted route.  I'll need to import my &lt;code&gt;auth&lt;/code&gt; module which we created above.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  var auth = require('../controllers/authController');
  ...
  // Get all users - Unrestricted Route
  app.get('/', userController.getAllUsers);

  // Get user by id - Restricted Route
  app.get('/:id', auth.authorize, userController.getUserById);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;jsonwebtoken&lt;/code&gt; npm module and setting up a some middleware and helper functions, it's very straightforward to get up and running with server side user authentication using JWTs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JWTs Client Side&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JWTs can be used to restrict client side routes.  Keep in mind that this is not entirely fool proof as these tokens are accessible to anyone in local storage and easily decoded.  Make sure not to store sensitive information, especially passwords, in JWTs and to keep any really sensitive information and actions exclusively on the server.&lt;/p&gt;

&lt;p&gt;That said, they are a very convenient way to have a user logged in and to restrict frontend routes the average user can visit.&lt;/p&gt;

&lt;p&gt;I used Angular on the frontend of my project and saved all relevant authentication logic in an &lt;code&gt;Auth&lt;/code&gt; service.  &lt;/p&gt;

&lt;p&gt;For brevity, I'll exclude the factory specific code. I wrote a number of helper functions, but they all revolve around saving the token to local storage, and checking if it exists to see if the user is logged in.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  // auth.js
  ...
  const storageKey = 'village.id_token';

  /**
   * Checks if a user has a token
   * @return {[boolean]} [if user is authorized]
   */
  const authorized = () =&amp;gt; {
    return !!getToken();
  };

  /**
   * Returns raw jwt from local storage
   * @return {[string]} [returns token or false if doesn't exist]
   */
  const getToken = () =&amp;gt; {
    return $window.localStorage.getItem(storageKey) || false;
  }

  /**
   * Save raw token to local storage.  Returns decoded token
   * @param  {[string]} token [jwt to save]
   * @return {[object]}       [decoded jwt]
   */
  const saveToken = (token) =&amp;gt; {
    $window.localStorage.setItem(storageKey, token);
    return decodeToken();
  }

  /**
   * Deletes jwt from storage
   * @return {[boolean]} [true]
   */
  const logOut = () =&amp;gt; {
    $window.localStorage.removeItem(storageKey);
    loggedInUser = null;
    return true;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the token in storage, we can decode it and access the data it contains.  In this case, I was using it to hold on to user specific information.  To easily decode the tokens, I included &lt;a href="https://github.com/auth0/angular-jwt"&gt;angular-jwt&lt;/a&gt; and injected &lt;code&gt;jwtHelper&lt;/code&gt; as a dependency into my service. I wrote in a helper function to handle decoding the token stored in local storage.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  // auth.js
  ...
  /**
   * Decodes raw jwt and returns payload
   * @return {[object]} [returns decoded payload]
   */
  const decodeToken = () =&amp;gt; {
    let token = getToken();
    if (token) {
      return jwtHelper.decodeToken(token);
    } else {
      return false;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By making use of these functions, it's easy to save a new token when a user logs in, to check if a user is already logged in, and get information about that user by decoding an existing token.&lt;/p&gt;

&lt;p&gt;In order for the user to take actions on the server, this token must be sent up with any outgoing request.  This allows the server to securely verify if the user is logged in with a valid JWT and subsequently allowed to take restricted server side actions.  With jQuery and ajax, it's a matter of adding the token as a header.  For Angular, it's possible to automatically attach the token on any outgoing requests by making use of &lt;code&gt;$httpProvider.interceptors&lt;/code&gt;.  The 'interceptors' is an array of factories, or factory style callbacks, exposing function methods to be run on http requests and responses.  In this case, we're only interested in outgoing requests, so we'll only define a single method, &lt;code&gt;request&lt;/code&gt; on our factory.  This configuration is done on the main module declaration in my Angular app.&lt;/p&gt;

&lt;p&gt;Check out more about &lt;code&gt;$httpProvider.interceptors&lt;/code&gt; &lt;a href="https://docs.angularjs.org/api/ng/service/$http#interceptors"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;...
// Set up JWT authentication
.config(['$httpProvider', function($httpProvider){

    // Intercept outgoing http requests and attach jwt token
    $httpProvider.interceptors.push('AttachJWT');
}])

.factory('AttachJWT', ['$window', function($window){

    return {
        // Attach jwt token if it exists
        request: (object) =&amp;gt; {
            let jwt = $window.localStorage.getItem('village.id_token');
            if(jwt){
                object.headers['x-access-token'] = jwt;
            }
            object.headers['Allow-Control-Allow-Origin'] = '*';
            return object;
        }

    };
}])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It's also possible to restrict users that are not logged in from accessing certain Angular routes.  By listening on the &lt;code&gt;$rootScope&lt;/code&gt; for a &lt;code&gt;$stateChangeStart&lt;/code&gt; event with &lt;code&gt;ui-router&lt;/code&gt;, or &lt;code&gt;$routeChangeStart&lt;/code&gt; with &lt;code&gt;ng-router&lt;/code&gt;, you can interrupt any restricted route changes if the user is not logged in.  &lt;/p&gt;

&lt;p&gt;This implementation will check if the target state has an &lt;code&gt;authenticate&lt;/code&gt; property set to true.  If so, it will check if there is a JWT present on the client.  If there is a JWT, the route change continues, if not, the user is redirected back to the 'sign in' state.&lt;/p&gt;

&lt;p&gt;The listener is set up in Angular's &lt;a href="http://stackoverflow.com/questions/20663076/angularjs-app-run-documentation"&gt;run block&lt;/a&gt; right after declaring and configuring the main module.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  ...
  .run(function($rootScope, $location, $state, Auth) {
    $rootScope.$on('$stateChangeStart', function(evt, toState, toParams) {
      if (toState &amp;amp;&amp;amp; toState.authenticate &amp;amp;&amp;amp; !Auth.authorized()) {
        console.log('not logged in');
        evt.preventDefault();
        $state.go('signin');
    }
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;authenticate&lt;/code&gt; property can be placed on the state when it is declared.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  $stateProvider.state('dashboard', {
      url: '/dashboard/',
      params: {
          userId: null
      },
      template: '&amp;lt;dashboard&amp;gt;&amp;lt;/dashboard&amp;gt;',
      authenticate: true
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are the essential elements in creating a user authentication system using JWTs.  JWTs are a very convenient method to authenticate users in a modern SPA, although they do have their drawbacks.  This is a simple implementation that only checks for the existence of a JWT on the client and a valid signature on the server.  You must take precautions when using JWTs as they still present a number of security risks.  Read more about potential issues &lt;a href="https://docs.angularjs.org/api/ng/service/$http#interceptors"&gt;here&lt;/a&gt;.  &lt;/p&gt;

&lt;p&gt;Despite that, they are a very convenient way to hang on to user data and authorization without having to constantly query the server.&lt;/p&gt;</content:encoded></item><item><title>Using Bookshelf in ExpressJS</title><description>&lt;p&gt;Apparently there are those among us who are really into writing SQL statements.  Good for you guys.  As for the rest of us, there's &lt;a href="http://bookshelfjs.org/"&gt;Bookshelf&lt;/a&gt;.  A sweet ORM for NodeJS, Bookshelf can be a nice layer of abstraction to make our lives a lot easier when setting up a SQL&lt;/p&gt;</description><link>http://localhost:2368/using-bookshelf-in-expressjs/</link><guid isPermaLink="false">e265951b-fa68-44eb-83e8-042f7214452e</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Wed, 03 Feb 2016 19:34:43 GMT</pubDate><content:encoded>&lt;p&gt;Apparently there are those among us who are really into writing SQL statements.  Good for you guys.  As for the rest of us, there's &lt;a href="http://bookshelfjs.org/"&gt;Bookshelf&lt;/a&gt;.  A sweet ORM for NodeJS, Bookshelf can be a nice layer of abstraction to make our lives a lot easier when setting up a SQL database. But as with anything in code, it takes a little investment in time and research before you can reap those benefits.&lt;/p&gt;

&lt;p&gt;I'm going to go through how to set up Bookshelf, connect it with an ExpressJS app, and how to set up a model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Structuring The Application&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I won't go into how to set up an Express app and getting your server running, but the application architecture I'm going to use will look like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── index.js
├── knexfile.js
├── package.json
└── server
    ├── collections
    │   └── users.js
    ├── config
    │   └── bookshelf.config.js
    ├── controllers
    │   └── userController.js
    ├── models
    │   └── user.js
    ├── routes
    │   └── userRouter.js
    └── server.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to Express and its dependencies, make sure and install &lt;code&gt;bookshelf&lt;/code&gt; and &lt;code&gt;knex&lt;/code&gt; and &lt;code&gt;mysql&lt;/code&gt; using &lt;code&gt;npm&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save knex bookshelf mysql  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Connecting Bookshelf&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The next step is to hook our app up to Bookshelf.  Bookshelf is based on the &lt;a href="http://knexjs.org/"&gt;Knex&lt;/a&gt; query builder.  We will need to first configure Knex as it is what will be managing the connection to our database.  Knex also allows us to run migrations to set up our tables and our schemas.  If you're interested in a walkthrough of how to run migrations in Knex, or if the next section makes no sense at all, check out my post here.&lt;/p&gt;

&lt;p&gt;Otherwise, make sure you have a file containing the connection information for Knex to reference.  Mine is set up as &lt;code&gt;knexfile.js&lt;/code&gt; in the root directory and looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// knexfile.js
var db = (process.env.NODE_ENV === 'test') ? 'bookshelf_test' : 'bookshelf'

module.exports = {

  client: 'mysql',
  connection: {
    host: '127.0.0.1',
    user: 'root',
    password: '',
    database: db,
    charset: 'utf8'
  },
  pool: {
    min: 2,
    max: 10
  },
  migrations: {
    tableName: 'knex_migrations'
  }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I've set it up to use MySQL, but you can use which ever &lt;a href="http://knexjs.org/#Installation-client"&gt;SQL flavor you prefer&lt;/a&gt;. Likewise, make sure your database is set up with a &lt;code&gt;users&lt;/code&gt; table with the necessary columns.  Here is my schema written out with Knex.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;knex.schema.createTable('users', function(table){  
      table.increments('id').primary();
      table.string('email').notNullable();
      table.string('password').notNullable();
      table.string('name');
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once that is all put together, we'll create a file which will configure and initialize Bookshelf for us.  My file lives in the &lt;code&gt;server/config/bookshelf.config.js&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// bookshelf.config.js

var knex = require('knex')(require('../../knexfile'));

var Bookshelf = require('bookshelf')(knex);

Bookshelf.plugin('registry');

module.exports = Bookshelf;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line grabs Knex and feeds it our configuration file so it can set up a connection to the database.  Next, we initialize Bookshelf by passing in our knex instance.  I have opted to use the &lt;a href="https://github.com/tgriesser/bookshelf/wiki/Plugin:-Model-Registry"&gt;registry plugin for Bookshelf&lt;/a&gt;  to make it easier to prevent model dependency issues.  Then, we export the whole thing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Creating a User Model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Models are the heart and soul of Bookshelf.  They give a convenient Object Oriented interface to allow you to manage the contents of your database.  They also make it much easier to manage the various relationship types in MySQL; many to many etc.  I'm going to save all the foreign key fun for another post.  Here, I'll create a simple model without any external relationships.&lt;/p&gt;

&lt;p&gt;In our models directory, we'll create a file called &lt;code&gt;user.js&lt;/code&gt; to hold on to our user model.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// user.js

var Bookshelf = require('../config/bookshelf.config');

var User = Bookshelf.Model.extend({

  tableName: 'users'

});

module.exports = db.model('User', User);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we import the &lt;code&gt;Bookshelf&lt;/code&gt; instance we set up earlier through our &lt;code&gt;bookshelf.config.js&lt;/code&gt; file.  &lt;/p&gt;

&lt;p&gt;As bookshelf's syntax is based on backbonejs, we extend the bookshelf model and, at minimum, tell bookshelf which database table to save the information on.&lt;/p&gt;

&lt;p&gt;Finally, we export our model.  The specific syntax here is based on the registry plugin (which we set up in the &lt;code&gt;bookshelf.config.js&lt;/code&gt; file).  As our models get more complex, through adding in many to many relationships and so on, we will need to include references to external models when we create each model.  Registry makes it cleaner to include outside models and gets rid of circular dependency issues.  Not an issue now, but a huge help as our data gets more complex.&lt;/p&gt;

&lt;p&gt;This is the basic form for our model.  To use it, just &lt;code&gt;require&lt;/code&gt; it inside your express app, and you have access to all the &lt;a href="http://bookshelfjs.org/#Model"&gt;model goodness&lt;/a&gt; that comes with Bookshelf.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Testing Our Model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Testing.  It's like eating kale or exercising.  Something you know you should be doing, but would rather do later.  Likewise, a little investment now, will make you feel way better in the future.&lt;/p&gt;

&lt;p&gt;Let's write out some tests to make sure our models work. I like using &lt;code&gt;mocha&lt;/code&gt; as a test framework and &lt;code&gt;chai&lt;/code&gt; as my assertion library.  Make sure and install them as dev dependencies.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save-dev mocha chai  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in &lt;code&gt;package.json&lt;/code&gt; add the following script so we can easily run &lt;code&gt;npm test&lt;/code&gt;.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;"scripts": {
    "test": "./node_modules/.bin/mocha"
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let's add a &lt;code&gt;test&lt;/code&gt; directory in our root directory and add in a file called &lt;code&gt;userModel.spec.js&lt;/code&gt;.  Mocha will look for a &lt;code&gt;test&lt;/code&gt; directory by default and try and run *.js files inside of it.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// userModel.spec.js

process.env.NODE_ENV = 'test';

var expect = require('chai').expect;  
var knex = require('knex')(require('../knexfile'));

var User = require('../server/models/user');

describe('User Route', function() {  
// Testing goodness goes here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To ensure that I'm working with a clean database, and to clean it out for subsequent tests, I'm going to use knex migrations.  While not necessary, it makes it a lot easier to setup and teardown the testing database while working on it.  Again check out my post here for more on migrations.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;beforeEach&lt;/code&gt; will clear out the database using &lt;code&gt;knex.migrate.rollback&lt;/code&gt;, then reapply our table schemas using &lt;code&gt;knex.migrate.latest&lt;/code&gt;.  Finally, we'll make sure and clear out the database by using &lt;code&gt;rollback&lt;/code&gt; again in our &lt;code&gt;after&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// userModel.spec.js
...
describe('User Route', function() {  
  beforeEach(function(done) {
    return knex.migrate.rollback()
      .then(function() {
        return knex.migrate.latest()
      })
      .then(function() {
        done();
      });
  });

  after(function (done) {
    return knex.migrate.rollback()
      .then(function(){
        done();
      });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our model is pretty simple at this point, so I'll just write two tests.  One as a sanity check to make sure that the model is working correctly and we have an empty database and the second to make sure we can save a model and then access it on the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javscript"&gt;    it('should not have any models', function (done) {
      User.forge().fetch().then(function(results){
        expect(results).to.equal(null);
        done()
      });
    });

    it('should save a model to the database', function (done) {
      var user = new User({
        email: 'test@test.com',
        password: 'defconbravo',
        name: 'Yossarian'
      }).save()
      .then(function(){
        return User.where({email: 'test@test.com'}).fetch();
      })
      .then(function(user){
        expect(user.get('name')).to.equal('Yossarian');
        done();
      });
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the terminal run &lt;code&gt;npm test&lt;/code&gt; and, hopefully, everything should be happily running along.&lt;/p&gt;

&lt;p&gt;There is a basic example of how to set up a bookshelf model and test it out.  In a later post, I hope to go through how to model more complex relationships using Bookshelf.&lt;/p&gt;</content:encoded></item><item><title>Running Migrations with Knex</title><description>&lt;p&gt;Knex can take a lot of the grunt work out of working with SQL databases in NodeJS.  On example is using Knex' migration functionality to set up and modify your table setup.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set up a knexfile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First step to getting started is to globally install knex.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g knex&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/running-migrations-with-knex/</link><guid isPermaLink="false">85ba9569-0777-4873-962b-c8392b4ff17c</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Wed, 03 Feb 2016 02:41:44 GMT</pubDate><content:encoded>&lt;p&gt;Knex can take a lot of the grunt work out of working with SQL databases in NodeJS.  On example is using Knex' migration functionality to set up and modify your table setup.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set up a knexfile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First step to getting started is to globally install knex.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g knex  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next inside your root directory, run:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;knex init  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will set up a &lt;code&gt;knexfile.js&lt;/code&gt; which will hang on to the configuration information for setting up your SQL db.  In this case, I'm going to wire it up to use MySQL.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// Update with your config settings.

module.exports = {

  development: {
    client: 'mysql',
    connection: {
      host: '127.0.0.1',
      user: 'root',
      password: '',
      database: '&amp;lt;YOUR TEST DB NAME&amp;gt;',
      charset: 'utf8'
    }
  },

  staging: {
    ...
  },

  production: {
    ...
  }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;knexfile&lt;/code&gt; you have the option of altering your configurations depending on your environment.  When running your migrations, you have the option of passing a &lt;code&gt;--env&lt;/code&gt; flag in command line to specify which environment you want to use. ie:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;knex migrate:latest --env production  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this example, I'll just write in an example using a local MySQL database.  The default &lt;code&gt;knexfile&lt;/code&gt; is a good reference, and you can check out more about configuring the connection in the &lt;a href="http://knexjs.org/#Installation-client"&gt;Knex docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Creating a Migration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After setting up your &lt;code&gt;knexfile.js&lt;/code&gt; to incorporate your preferred SQL flavor, pop open your terminal and point it to your project's root directory.&lt;/p&gt;

&lt;p&gt;In there, run:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;knex migrate:make setup  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will create a &lt;code&gt;migrations&lt;/code&gt; directory and place a a migration file inside of it.&lt;/p&gt;

&lt;p&gt;Open up that file and add something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;exports.up = function(knex, Promise) {  
  return Promise.all([
    knex.schema.createTable('users', function(table){
      table.string('username');
      table.string('password');
      table.timestamps();
    })
  ])
};

exports.down = function(knex, Promise) {  
  return Promise.all([
    knex.schema.dropTable('users');
  ])
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each migration is expecting two functions on its API, &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt;.  &lt;code&gt;up&lt;/code&gt; is called when the migration is applied, and &lt;code&gt;down&lt;/code&gt; is called on a migration rollback.&lt;/p&gt;

&lt;p&gt;In those functions you can use any of &lt;a href="http://knexjs.org/#Schema"&gt;Knex' Schema Functions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To make it easier to run rollbacks, your &lt;code&gt;down&lt;/code&gt; function should 'undo' your &lt;code&gt;up&lt;/code&gt; function.  In this case, because we are creating a table in &lt;code&gt;up&lt;/code&gt;, we need to remove that table in &lt;code&gt;down&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To apply your new migration, in the terminal, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;knex migrate:latest  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Updated Your Tables&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To make a change to your tables, create another migration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;knex migrate:make step1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the new migration file, you can make changes to your table, again making use of any of Knex' schema functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;exports.up = function(knex, Promise) {  
  return Promise.all([
    knex.schema.table('users', function(table){
      table.string('twitter');
    })
  ])
};

exports.down = function(knex, Promise) {  
  return Promise.all([
    knex.schema.table('users', function(table){
      table.dropColumn('twitter');
    })
  ])
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here because we add a new column in &lt;code&gt;up&lt;/code&gt;, we'll remove it in &lt;code&gt;down&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rollback&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To remove the changes we've made so far, in the terminal run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;knex migrate:rollback  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the migrations you've made will be rolled back.&lt;/p&gt;

&lt;p&gt;Using Knex' migrate functionality, creating and modifying your table schemas is a lot easier.  So unless you really dig writing out longhand SQL statements, Knex will make your life a lot easier.  &lt;/p&gt;</content:encoded></item><item><title>Finding All Permutations of a String in Python</title><description>&lt;p&gt;In my quest to learn the intricacies of Python, I came across one of my favorite algorithms; finding all the possible permutations of a string.&lt;/p&gt;

&lt;p&gt;To lay it out:  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-python"&gt;# Given string 'ab'
# Permutation list ['a', 'ab', 'b', 'ba']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a poster child for recursion.  To set it up, we'll&lt;/p&gt;</description><link>http://localhost:2368/finding-all-permutations-of-a-string-in-python/</link><guid isPermaLink="false">2602c66b-1b52-4ae4-89de-96d4416aa066</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Mon, 01 Feb 2016 21:42:19 GMT</pubDate><content:encoded>&lt;p&gt;In my quest to learn the intricacies of Python, I came across one of my favorite algorithms; finding all the possible permutations of a string.&lt;/p&gt;

&lt;p&gt;To lay it out:  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-python"&gt;# Given string 'ab'
# Permutation list ['a', 'ab', 'b', 'ba']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a poster child for recursion.  To set it up, we'll have our primary function, &lt;code&gt;string_permutations&lt;/code&gt;, but also define a &lt;code&gt;subroutine&lt;/code&gt; that will do our recursive dirt work.  We'll also create a &lt;code&gt;combos&lt;/code&gt; list to hold onto our permutations.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python -tt

def string_permutations(string):

  def sub_routine(...some args):
    combos = []
    return combos

  return sub_routine(...some args)

def main():  
  # print string_permutations('ab')

if __name__ == "__main__":  
  main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We'll pass in two list arguments to &lt;code&gt;sub_routine&lt;/code&gt;.  The first will hold on to all the characters that we have 'used' so far, and the other will hold on to the characters that we still have left to use.  We can call &lt;code&gt;sub_routine&lt;/code&gt; in our parent function beginning with an empty list for 'used' characters, and a list made of all characters in the target string as the initial 'left' characters.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-python"&gt;...
def sub_routine(used, left):  
  combos = []
  return combos

return sub_routine([], list(string))  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside our &lt;code&gt;sub_routine&lt;/code&gt; function, we can begin generating our permutations. First, we'll loop through each index in the &lt;code&gt;left&lt;/code&gt; list.  Looping the index and not the character itself, will make it easier to manage the recursion later on.  Then, we'll remove the character from the &lt;code&gt;left&lt;/code&gt; list at that index and add it to the end of the &lt;code&gt;used&lt;/code&gt; list.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;used&lt;/code&gt; list will represent our permutation so far.  We're not implementing restrictions on the size of the permutations, so each iteration will represent a unique permutation.  We can then push that permutation to our &lt;code&gt;combos&lt;/code&gt; list.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-python"&gt;...
def sub_routine(used, left):  
  combos = []

  for i in range(0, len(left)):
    ch = left.pop(i)
    used.append(ch)

    combos.append(''.join(used))


  return combos

return sub_routine([], list(string))  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, here comes the fun part.  For each permutation we start building, we need to add on all combinations of remaining characters.  So let's get a little recursive.&lt;/p&gt;

&lt;p&gt;What we'll do is pass in the new &lt;code&gt;used&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt; lists to a recursive call to our &lt;code&gt;sub_routine&lt;/code&gt;.  Since our &lt;code&gt;sub_routine&lt;/code&gt; will return all of its subsequent permutations, we can concatenate the result of our recursive call with our &lt;code&gt;combos&lt;/code&gt; array.&lt;/p&gt;

&lt;p&gt;The tricky part comes in after we make the recursive call.  We have to reset the contents of left and used so that when we continue on in the for loop, we can access the next character properly.&lt;/p&gt;

&lt;p&gt;For example, on the first iteration of 'ab':  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-python"&gt;# First iteration: 
# ch will equal 'a'
# We will put 'a' into our used array as the first character.
# All subsequent recursive calls down this path will have 'a' as the first character.
# We finish the recursive chain, and replace 'a' in left and remove 'a' from used.


#Second Iteration:
# ch will equal 'b'
# We will put 'b' into our used array as the first character.
# All subsequent recursive calls down this path will have 'b' as the first character.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of these steps will be repeated as part of the recursion with the result that each permutation will be visited.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python -tt

def string_permutations(string):

  def sub_routine(used, left):

    combos = []

    for i in range(0, len(left)):
      ch = left.pop(i)
      used.append(ch)

      combos.append(''.join(used))

      # Append the results of the 
      # recursive call to our combos list
      combos = combos + sub_routine(used, left)


      # Remove ch from used
      used.pop(-1)
      # Splice ch back into left at its original index
      left[i:0] = [ch]

    return combos

  return sub_routine([], list(string))

def main():  
  print string_permutations('ab')

if __name__ == "__main__":  
  main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Knocking out a permutations algorithm always makes me feel like a recursive badass.&lt;/p&gt;</content:encoded></item><item><title>Streaming Files from S3 Using AWS Cloudfront</title><description>&lt;p&gt;For a recent project I was working on, we needed to host a bunch of audio files for our web app and make them streamable to the client.  My original implementation made use of Nodejs streams to stream content hosted on S3 down to the client.  Check out that implementation&lt;/p&gt;</description><link>http://localhost:2368/streaming-files-from-s3-using-aws-cloudfront/</link><guid isPermaLink="false">93e58cd9-3a03-486c-8b74-607695e4b098</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Wed, 27 Jan 2016 22:25:15 GMT</pubDate><content:encoded>&lt;p&gt;For a recent project I was working on, we needed to host a bunch of audio files for our web app and make them streamable to the client.  My original implementation made use of Nodejs streams to stream content hosted on S3 down to the client.  Check out that implementation &lt;a href="http://alexzywiak.github.io/streaming-audio-goodness-from-amazon-s3-to-the-clients-ears/"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And then totally disregard that.  Very soon afterward, I discovered AWS Cloudfront which offers a much better way to host and stream files.  Cloudfront lets you associate a distribution with an existing S3 bucket and make select files streamable or generally available.&lt;/p&gt;

&lt;p&gt;I'll briefly go through here how to start make S3 hosted audio files available for streaming on a client.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Link to S3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Assuming you have a bucket up and running on S3 with some files you want to make available, head on over to the &lt;a href="https://console.aws.amazon.com/cloudfront/home"&gt;Cloudfront Dashboard&lt;/a&gt;.  &lt;/p&gt;

&lt;p&gt;Click &lt;code&gt;Create Distribution&lt;/code&gt; &lt;br&gt;
Then choose &lt;code&gt;Web&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;On the next screen set the &lt;code&gt;Origin Domain Name&lt;/code&gt; to the bucket you want to set up the distribution for.  Optionally, add in an &lt;code&gt;Origin Path&lt;/code&gt; to specify a folder in the bucket to use as the default origin.&lt;/p&gt;

&lt;p&gt;Click &lt;code&gt;Create Disrtibution&lt;/code&gt; down at the bottom, and it will get up and running.&lt;/p&gt;

&lt;p&gt;Back in your dashboard, you should see the new distribution along with some information about it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Setting Up Permissions on your Bucket&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;to make the files available for streaming, you have to make them 'public' in your bucket.  There are a few ways to do this depending on what you're hosting.&lt;/p&gt;

&lt;p&gt;1)  You can simply right click on any files in your bucket and choose &lt;code&gt;Make Public&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2)  You can right click on a folder and choose &lt;code&gt;Make Public&lt;/code&gt;.  This will grant access to all files currently in the folder, but new files added into the folder will not be made public by default.&lt;/p&gt;

&lt;p&gt;3)  Probably your best bet, is to set up a bucket policy.  These set up global permission defaults for your bucket and give you a lot of fine grained control over what you want to share, and with whom.  &lt;/p&gt;

&lt;p&gt;To edit a bucket policy, right click your bucket and choose &lt;code&gt;Properties&lt;/code&gt;. &lt;br&gt;
Click &lt;code&gt;Permissions&lt;/code&gt; --&gt; &lt;code&gt;Add bucket policy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here are some &lt;a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html"&gt;example bucket policies&lt;/a&gt; from Amazon/  Copy, paste, modify, and save as your new bucket policy.  &lt;/p&gt;

&lt;p&gt;Here's a basic boilerplate to allow users to stream files from your bucket.  It will let users get access to any &lt;code&gt;.wav&lt;/code&gt; files in your &lt;code&gt;public&lt;/code&gt; folder in the specified bucket.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  "Version":"2012-10-17",
  "Statement":[
    {
      "Sid":"AddPerm",
      "Effect":"Allow",
      "Principal": "*",
      "Action":["s3:GetObject"],
      "Resource":["arn:aws:s3:::examplebucket/public/*.wav"]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Accessing Files on the Client&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Once your new Cloudfront distribution is in an Enabled state and you have updated your bucket permissions, you can access your files through the client.&lt;/p&gt;

&lt;p&gt;Back in the Cloudfront dashboard, grab the &lt;code&gt;Domain Name&lt;/code&gt; for your distribution, then append the S3 folder path and filename of a file to stream.  &lt;/p&gt;

&lt;p&gt;For example, to get at &lt;code&gt;test.wav&lt;/code&gt; in the &lt;code&gt;public&lt;/code&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; what ever cloud front string &amp;gt;.cloudfront.net/public/test.wav  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Put that into your browser and you should be able to stream your file.&lt;/p&gt;

&lt;p&gt;Like wise, to make it available on an html page add it as the source to an audio tag, and you're good to go!&lt;/p&gt;</content:encoded></item><item><title>Managing Multiple Child Processes in NodeJS</title><description>&lt;p&gt;In a recent project, I needed to run some audio processing functions on a serious amount of audio files.  As we were running on a small time server, this was a little too taxing for our intro level RAM allotments.  So I looked into outsourcing the heavy lifting into separate&lt;/p&gt;</description><link>http://localhost:2368/managing-multiple-child-processes-in-nodejs/</link><guid isPermaLink="false">baa6d50d-062b-4969-8363-24c400992b6b</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Wed, 20 Jan 2016 23:02:38 GMT</pubDate><content:encoded>&lt;p&gt;In a recent project, I needed to run some audio processing functions on a serious amount of audio files.  As we were running on a small time server, this was a little too taxing for our intro level RAM allotments.  So I looked into outsourcing the heavy lifting into separate child processes and then limiting the total concurrent number of processes running at any given time.&lt;/p&gt;

&lt;p&gt;In this post, I'm going to go through the steps I came up with.  First, how to create a child process in a separate file and run it using the &lt;code&gt;spawn&lt;/code&gt; method.  Next, how to promisify the process and pass arguments to it.  Lastly, how to queue up a whole bunch of those processes and limiting the total number that will be run concurrently.&lt;/p&gt;

&lt;p&gt;If you're just here for some sweet code, &lt;a href="https://github.com/alexzywiak/nodejs-childprocesses-bluebird"&gt;here's&lt;/a&gt; the repo with the example code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outsourcing a Child Process&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The only npm dependency we'll need is &lt;code&gt;bluebird&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm init  
npm install --save bluebird  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our driver file will be in &lt;code&gt;index.js&lt;/code&gt; and we'll put our child process login in &lt;code&gt;process.js&lt;/code&gt;. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── index.js
├── node_modules
├── package.json
└── process.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We'll use a trivial example for our child process logic.  It will run a &lt;code&gt;setTimeout&lt;/code&gt; function to simulate a delay.  It will send data to the parent process using &lt;a href="https://nodejs.org/api/process.html#process_process_stdout"&gt;process.stdout&lt;/a&gt;.  It will send some trivial data when it is initiated and again after two seconds when it is completed.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// process.js

    process.stdout.write('Process beginning.');

    setTimeout(function(){
        process.stdout.write('Process complete.');
    }, 2000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our &lt;code&gt;index.js&lt;/code&gt; file will use the &lt;a href="https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options"&gt;spawn&lt;/a&gt; function from Node's &lt;code&gt;child_process&lt;/code&gt; module to call &lt;code&gt;process.js&lt;/code&gt;.  Spawn needs to be passed in two parameters to run and external file.  The first is the command to run the file, in this case &lt;code&gt;node&lt;/code&gt;, and the second is an array of arguments, the first of which, will be the file path of the file we would like to run, in this case &lt;code&gt;'./process.js'&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our child process is sending data through the &lt;code&gt;process.stdout.write()&lt;/code&gt; function, but we need to set up listeners in the parent process to get access to that data and simply write it to the console.  The data that comes back is in the form of a &lt;code&gt;buffer&lt;/code&gt; so we'll have to call buffer's &lt;code&gt;.toString&lt;/code&gt; method on it to convert into something comprehensible. &lt;/p&gt;

&lt;p&gt;We'll set up listeners for three events on the child, a data event from &lt;code&gt;process.stdout&lt;/code&gt;, data in the case of an error from &lt;code&gt;process.stderr&lt;/code&gt; and finally, we'll listen for the &lt;code&gt;exit&lt;/code&gt; event on &lt;code&gt;process&lt;/code&gt;.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// index.js
var spawn = require('child_process').spawn;  
var bbPromise = require('bluebird');

function loadProcess() {

  var process = spawn('node', ['./process.js']);

  process.stdout.on('data', function(data) {
    console.log(data.toString());
  });

  process.stderr.on('data', function(err) {
    reject(err.toString());
  });

  process.on('exit', function() {
    console.log('Done!');
  });

}

loadProcess();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Runnning:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node index.js  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Will get us:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Process  beginning.  
Process complete.  
Done!  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Running Multiple Instances with Arguments&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While our previous example is truly fascinating, let's pass some arguments to our child process and use promises so we can queue up a whole bunch.&lt;/p&gt;

&lt;p&gt;First we'll modify our index.js file to pass in arguments to our child processes.  The second parameter to &lt;code&gt;spawn&lt;/code&gt; is an array that accepts any number of elements and makes them available to the child process via &lt;code&gt;process.argv&lt;/code&gt; array.  Our &lt;code&gt;loadProcess&lt;/code&gt; function will take in a parameter, &lt;code&gt;arg&lt;/code&gt;, and will pass it to the child process via the spawn function as the second element in the arguments array.&lt;/p&gt;

&lt;p&gt;We'll also wrap the event listeners in a bluebird promise, and resolve the promise when the process is complete.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//index.js
 function loadProcess(arg) {

    return new bbPromise(function(resolve, reject) {
      var process = spawn('node', ['./process.js', arg]);

      process.stdout.on('data', function(data) {
        console.log(data.toString());
      });

      process.stderr.on('data', function(err) {
        reject(err.toString());
      });

      process.on('exit', function() {
        resolve();
      });
    });
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We'll make a slight modification to &lt;code&gt;process.js&lt;/code&gt; so we can get access to the passed &lt;code&gt;arg&lt;/code&gt; value.  All arguments passed into spawn will be available in the child process in the &lt;code&gt;process.argv&lt;/code&gt; property.  This property is an array, and the first two elements will be the &lt;code&gt;'node'&lt;/code&gt; command and the filepath respectively, so our value will be happily residing at &lt;code&gt;process.argv[2]&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//process.js
var value = process.argv[2];

    process.stdout.write('Process ' + value + ' beginning.');

    setTimeout(function(){
        process.stdout.write('Process ' + value + ' complete.');
    }, 2000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, to make use of our promises, we'll queue up a whole bunch of the child process using different arguments.  Then, using &lt;a href="http://bluebirdjs.com/docs/api/map.html"&gt;bluebird's map&lt;/a&gt; function, we'll execute each process, and execute a function when they have all resolved.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// index.js
...
  var commands = [1, 2, 3, 4, 5].map(function(value) {
    return loadProcess.bind(null, value);
  });

  return bbPromise.map(commands, function(command) {
    return command();
  })
  .then(function() {
    console.log('Child Processes Completed');
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create our commands array to be composed of function references to &lt;code&gt;loadProcess&lt;/code&gt; bound to different argument values, in this case the numbers one through five.&lt;/p&gt;

&lt;p&gt;Then, bluebird's map function will iterate over each command, which are each promises remember, and execute that command. Then, it will console.log when they have all completed.&lt;/p&gt;

&lt;p&gt;Running  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node index.js  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Should get you something along the lines of  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Process 4 beginning.  
Process 2 beginning.  
Process 5 beginning.  
Process 1 beginning.  
Process 3 beginning.  
Process 4 complete.  
Process 2 complete.  
Process 5 complete.  
Process 1 complete.  
Process 3 complete.  
Child Processes Completed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Limiting the Number of Concurrent Processes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Up above, it's a bit of the wild west out there.  Processes are flying in any order and all running at the same time.  What if we needed to run them serially?  Or what if we needed to limit the total number going at one time?&lt;/p&gt;

&lt;p&gt;Bluebird's map function, simply enough, accepts a concurrency argument which will limit the total number of unresolved promises it will have running at any given time.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//index.js 
...
  return bbPromise.map(commands, function(command) {
    return command();
  }, {
    concurrency: 1
  })
  .then(function() {
    console.log('Child Processes Completed');
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a concurrency of one, running index.js will execute each process in order, and will only start after the previous has resolved.  Increasing the concurrency value, will start running that number of processes at the same time.  Try it out!&lt;/p&gt;</content:encoded></item><item><title>Spinning up a NodeJS Server from Scratch on Digital Ocean</title><description>&lt;p&gt;Digital Ocean takes a little more set up than Heroku, but once you get it going, it is blissfully easy to use.  DO gives you access to a CLI on your server's file system where you can npm, grunt, and node to your heart's content.  It's a refreshingly transparent system&lt;/p&gt;</description><link>http://localhost:2368/spinning-up-a-nodejs-server-from-scratch-on-digital-ocean/</link><guid isPermaLink="false">62334f29-188f-45a6-944d-79ccac7c2737</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Fri, 08 Jan 2016 00:20:09 GMT</pubDate><content:encoded>&lt;p&gt;Digital Ocean takes a little more set up than Heroku, but once you get it going, it is blissfully easy to use.  DO gives you access to a CLI on your server's file system where you can npm, grunt, and node to your heart's content.  It's a refreshingly transparent system after the rather opaque world of Heroku's Dyno's and build packs.&lt;/p&gt;

&lt;p&gt;What I'll walk through here is setting up a Digital Ocean droplet, their clever euphemism for a server instance.  Once we have our droplet set up, we'll install the necessary NodeJS packages, install Git, and clone over a repository.  Once we have that going, we'll briefly go through how to set up your DNS to point to your droplet and how to get the server to respond appropriately to traffic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set Up a Droplet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First up, head on over to &lt;a href="https://www.digitalocean.com/"&gt;Digital Ocean&lt;/a&gt; and sign yourself up.&lt;/p&gt;

&lt;p&gt;Before you hit that enticing little 'Create Droplet' button, let's set up an SSH key to make our lives easier.  An SSH key will allow you to directly access your droplet's file system from your terminal.  After logging in, navigate to &lt;a href="https://cloud.digitalocean.com/settings/security"&gt;Settings &gt; User &gt; Security&lt;/a&gt; and click 'Add SSH Key'.  &lt;/p&gt;

&lt;p&gt;For more detailed instructions, follow Digital Ocean's own excellent tutorial on SSH keys &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets"&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively, TL;DR:&lt;/p&gt;

&lt;p&gt;In your terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the file.  Passphrase optional. Then type out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cat ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print out the public SSH key, which you can then paste into the text area in the Security page.  Give the key a name, and save it.&lt;/p&gt;

&lt;p&gt;At this point, go ahead and hit 'Create a Droplet'.  Get it to run on Ubuntu, the default, and choose your size and location.  Make sure to &lt;strong&gt;add the SSH key you just created&lt;/strong&gt; in the 'Add Your SSH Keys' section!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set up Your Environment&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The droplet is up a running at this point, let's get it to do its job.  In the droplet menu, copy the IP address of your new droplet.  Then open up your terminal, and type the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh root@YOUR DROPLET IP  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tell it 'yes', and you're in!&lt;/p&gt;

&lt;p&gt;To start setting up the server environment, we'll use &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-manage-packages-in-ubuntu-and-debian-with-apt-get-apt-cache"&gt;apt-get&lt;/a&gt; as a package manager.&lt;/p&gt;

&lt;p&gt;First off run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then install some essentials:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install nodejs npm git  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it's as simple as running &lt;code&gt;git clone &amp;lt;your repo URL of choice&amp;gt;&lt;/code&gt; in your droplet.  Once in there, an &lt;code&gt;npm install&lt;/code&gt; will get all your packages going.  If you need grunt or gulp, just install their cli tools through npm and build away.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Setting up an App Server&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is a summation of this excellent &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-14-04"&gt;Digital Ocean Tutorial&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;To run the node server on the droplet, we'll use PM2 as a process manager.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install pm2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pm2 will be responsible for handling our &lt;strong&gt;app server&lt;/strong&gt; on our droplet. Run pm2 start to get things going.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm2 start &amp;lt;server file&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, if you visit your droplet's IP:&amp;lt; port #&gt; in your browser, you should see your app up and running.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Setting Up a Web Server&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Again, referencing &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-14-04"&gt;Digital Ocean Tutorial&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Digital Ocean recommends setting up a Reverse Proxy with &lt;a href="https://www.nginx.com/"&gt;nginx&lt;/a&gt; as a &lt;strong&gt;web server&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Essentially, nginx will tell any incoming requests to our DNS which IP to go look at.  First, we'll install it using &lt;code&gt;apt-get&lt;/code&gt;, and then will set up a config file to route incoming requests to the proper IP.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install nginx  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then to get at the config file we need:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/nginx/sites-available/default  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, as per the Digital Ocean tutorial, replace the contents of that file with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; {
    listen 80;

    server_name example.com;

    location / {
        proxy_pass http://APP_PRIVATE_IP_ADDRESS:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Set up DNS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For reference, here's &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-host-name-with-digitalocean"&gt;Digital Ocean's Guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once you have that the app and web servers up and running on your droplet, its a matter of setting up your DNS to point to it. First head on over to the service that manages your domain name, goDaddy etc., and point the nameservers associated with your domain name to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NS1.DIGITALOCEAN.COM  
NS2.DIGITALOCEAN.COM  
NS3.DIGITALOCEAN.COM  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, in your Digital Ocean Dashboard, navigate to the Networking &gt; Domain menu.  While there, in the appropriate fields, fill in your domain name and your droplet of choice and hit 'Create Record'.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That should get you where you need to be.  Your app is live and hosted on a domain name of your choice!  Digital Ocean takes a bit more set up than something like Heroku, but you also have a lot more control over how things are being run on your server!&lt;/p&gt;</content:encoded></item><item><title>Streaming Audio Goodness from Amazon S3 to the Client's Ears</title><description>&lt;p&gt;Built up this cool little feature the other day for a project of mine.  I'm going to go through how I got audio files stored on Amazon's S3 to stream down from on high and play in the browser.&lt;/p&gt;

&lt;p&gt;If you're only here for the code, &lt;a href="https://github.com/alexzywiak/s3StreamExample"&gt;here you go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If&lt;/p&gt;</description><link>http://localhost:2368/streaming-audio-goodness-from-amazon-s3-to-the-clients-ears/</link><guid isPermaLink="false">392b596b-c74e-4f9a-8158-fd6ad9d4ecdf</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Wed, 06 Jan 2016 02:58:38 GMT</pubDate><content:encoded>&lt;p&gt;Built up this cool little feature the other day for a project of mine.  I'm going to go through how I got audio files stored on Amazon's S3 to stream down from on high and play in the browser.&lt;/p&gt;

&lt;p&gt;If you're only here for the code, &lt;a href="https://github.com/alexzywiak/s3StreamExample"&gt;here you go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you don't have an &lt;a href="https://aws.amazon.com/"&gt;Amazon Web Service&lt;/a&gt; account, you're going to need to head over there to get some creds.&lt;/p&gt;

&lt;p&gt;This S3 streamer will be split up into three files along with a loading GIF so users don't get impatient.&lt;/p&gt;

&lt;pre&gt;
- index.html
- server.js
- config.js
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Server Set Up&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First, we'll whip up an express server to handle two routes.  One route will serve up &lt;code&gt;index.html&lt;/code&gt; and the other will stream our S3 sounds.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var express = require('express');  
var app = express();

// Serve up index.html
app.use('/', express.static(__dirname));

app.get('/audio', function(req, res) {  
  // Add s3 streaming in here
});

// Start Listenin
app.listen(3000, function() {  
  console.log('makin music on 3000');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we'll have to configure an S3 client.  I found the &lt;a href="https://www.npmjs.com/package/s3"&gt;s3&lt;/a&gt; npm module to be really easy to use.  It lets you set up a client, upload and download files without too much extra work.  That said, it's a pretty high level  module and if you need finer control over what's going on up there, check out (knox)[https://www.npmjs.com/package/knox] or the official Amazon module &lt;a href="https://www.npmjs.com/package/aws-sdk"&gt;aws-sdk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Make sure and install &lt;code&gt;s3&lt;/code&gt; then require it in &lt;code&gt;server.js&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;npm install s3&lt;/pre&gt;

&lt;p&gt;S3 will need to check out credentials first.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var s3 = require('s3');

//...

// Set up s3 credentials
var client = s3.createClient({  
  s3Options: {
    accessKeyId: &amp;lt;YOUR ACCESS KEY&amp;gt;,
    secretAccessKey: &amp;lt;YOUR SECRET KEY&amp;gt;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That done, we'll fill in our route.  To stream audio, &lt;code&gt;s3&lt;/code&gt; includes a &lt;code&gt;downloadStream&lt;/code&gt; method which will create a read stream pointed at a file stored on S3 and then pipe it down to the client response.  &lt;/p&gt;

&lt;p&gt;To tell &lt;code&gt;s3&lt;/code&gt; which file we want to download, we need to pass it the name of the S3 Bucket it is stored in as well as its Key value.  I have an mp3 file cleverly named &lt;code&gt;test.mp3&lt;/code&gt; stored in a bucket named &lt;code&gt;New-Bucket-1020&lt;/code&gt;.  Of course, yours can be named whatever your heart desires.  We'll save the bucket and key information in a &lt;code&gt;params&lt;/code&gt; object and pass that to the &lt;code&gt;downloadStream&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;We'll attach two event listeners onto the download stream.  One to check for errors and send a 404 if the files doesn't exist, and the other to listen for incoming headers.  When the headers come in, we'll send that information down to the client so it knows what the hell is going on.&lt;/p&gt;

&lt;p&gt;Finally, we'll pipe &lt;code&gt;downloadStream&lt;/code&gt; to the response to get the tunes flowing.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;app.get('/audio', function(req, res) {

  var params = {
    Bucket: 'New-Bucket-1020',
    Key: 'test.mp3'
  };

  var downloadStream = client.downloadStream(params);

  downloadStream.on('error', function() {
    res.status(404).send('Not Found');
  });
  downloadStream.on('httpHeaders', function(statusCode, headers, resp) {
    // Set Headers
    res.set({
      'Content-Type': headers['content-type']
    });
  });

  // Pipe download stream to response
  downloadStream.pipe(res);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Set Up the Client&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;On &lt;code&gt;index.html&lt;/code&gt; we'll render two buttons, &lt;code&gt;play&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;, which will do exactly what you hope they would.  &lt;/p&gt;

&lt;p&gt;We'll include a script that will start by grabbing the browser's &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext"&gt;AudioContext&lt;/a&gt; so we can get access to the speakers.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;play&lt;/code&gt; button will call the &lt;code&gt;playTunes&lt;/code&gt; function which will trigger an ajax request to our server which will start the audio stream.  When the data comes through, we'll put it through a helper function, &lt;code&gt;process&lt;/code&gt; which will do most of our work.  The &lt;code&gt;process&lt;/code&gt; function will create a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createBufferSource"&gt;buffer source node&lt;/a&gt;, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/decodeAudioData"&gt;decode&lt;/a&gt; the Data from our stream, plug it into the user's speakers, and tell the source to start playing.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;    window.AudioContext = window.AudioContext ||     window.webkitAudioContext;
    var context = new AudioContext();

// ...

    function playTunes() {
      var request = new XMLHttpRequest();
      request.open("GET", "http://localhost:3000/audio/", true);
      request.responseType = "arraybuffer";

      spinner.show();

      request.onload = function() {
          spinner.hide();
        var Data = request.response;
        process(Data);
      };

      request.send();
    }

    function process(Data) {
      source = context.createBufferSource(); // Create Sound Source
      context.decodeAudioData(Data, function(buffer) {
        source.buffer = buffer;
        source.connect(context.destination);
        source.start(context.currentTime);
      });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, we'll add a function to stop the music, and some logic to show/hide a spinner gif while we're waiting for the stream to come on down from the server.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;    var spinner = document.getElementById('spinner');

    spinner.hide = function(){
        this.style.display = 'none';
    };

    spinner.show = function(){
        this.style.display = 'block';
    }

    function stopTunes(){
        if(source.stop){
            source.stop();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our HTML will look like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;&amp;lt;!DOCTYPE html&amp;gt;  
&amp;lt;html&amp;gt;  
&amp;lt;head&amp;gt;  
    &amp;lt;title&amp;gt;S3 Audio&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;  
&amp;lt;body&amp;gt;  
    &amp;lt;button onclick="playTunes()"&amp;gt;Play&amp;lt;/button&amp;gt;
    &amp;lt;button onclick="stopTunes()"&amp;gt;Stop&amp;lt;/button&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;img id="spinner" style="display:none" src="ajax-loader.gif" alt=""&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt; // app logic &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there it is!  A quick way to stream audio samples down from S3.  Full code is right &lt;a href="https://github.com/alexzywiak/s3StreamExample"&gt;here&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title>Best of Both Worlds: Modelling Relational Data With Mongoose</title><description>&lt;p&gt;The relational debate rages on.  On the relational side of things, you have single sources of truth, all the joins you could possibly want, and fast queries on everything you could possibly imagine. Then you got the rebels tossing around POJOs and rapidly iterating the super loose tables.  What is&lt;/p&gt;</description><link>http://localhost:2368/best-of-both-worlds-modelling-relational-data-with-mongoose/</link><guid isPermaLink="false">3ca79ea9-2298-4635-88e4-318d59778625</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Sat, 12 Dec 2015 22:13:42 GMT</pubDate><content:encoded>&lt;p&gt;The relational debate rages on.  On the relational side of things, you have single sources of truth, all the joins you could possibly want, and fast queries on everything you could possibly imagine. Then you got the rebels tossing around POJOs and rapidly iterating the super loose tables.  What is a dev to do?&lt;/p&gt;

&lt;p&gt;I was working on a project where we were modelling some highly related data using MongoDB, projects as parts of an organization, and we came up against the inevitable existential question, to embed or not to embed?&lt;/p&gt;

&lt;p&gt;Embedding documents keeps everything in one place and makes all relevant data easily accessible with a single query.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//Organizations - Embedded
{
  name: 'Organization',
  projects: [{name: 'project1'}, {name:'project2'}]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creating separate collections means we have only one source of truth to make updates on and we can easily access any piece of the hierarchy.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//Organizations - Separate Collections
{
  name: 'Organization',
  projects: [project1._id, project2._id]
}
// Projects collection
{
  name: 'Project1'
}
{
  name: 'Project2'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We ended up choosing to separate out the collections.  There was too much overlap between different documents; if you updated one sub document, you had to make sure it was updated everywhere.  And it proved very difficult to make complex queries and operations on sub documents.  That being said, how can you conveniently link related documents together in MongoDB?&lt;/p&gt;

&lt;p&gt;The solution I ended up using was to create separate collections using Mongoose &lt;a href="http://mongoosejs.com/docs/2.7.x/docs/populate.html"&gt;DB-refs&lt;/a&gt; to link related documents on different collections, and then creating a middleware function to auto-populate the documents with their db-refs on any query.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DB-refs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DB-refs essentially save a reference to an _id property for one or many other documents that are related to the current document.  From the Mongoose docs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var StorySchema = new Schema({  
    _creator : { type: Schema.ObjectId, ref: 'Person' }
  , title    : String
  , fans     : [{ type: Schema.ObjectId, ref: 'Person' }]
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The story schema can be linked to a single _creator document and any number of fan documents.  These references will be saved in the &lt;code&gt;_creator&lt;/code&gt; and &lt;code&gt;fans&lt;/code&gt; properties respectively.  To set up these connections, you only need to save the corresponding _id value in _creator.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var aaron = new Person({ name: 'Aaron', age: 100 });

aaron.save(function (err) {  
  if (err) ...

  var story1 = new Story({
      title: "A man who cooked Nintendo"
    , _creator: aaron._id
  });

  story1.save(function (err) {
    if (err) ...
  });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the story document has a reference to 'aaron', its creator.  To get access to this document, you can 'populate' it to fill in all the DB-ref fields with the documents that they actually reference.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;Story  
.findOne({ title: /Nintendo/i })
.populate('_creator', ['name']) // &amp;lt;-- only return the Persons name
.exec(function (err, story) {
  if (err) ..

  console.log('The creator is %s', story._creator.name);
  // prints "The creator is Aaron"

  console.log('The creators age is %s', story._creator.age)
  // prints "The creators age is null'
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this is all well and good, but you have to set up the query to populate.  And what if you have multiple fields you want to populate?  And what if you want to do it all the time?  It would be pain in the ass to have to include populate on every single query you write out, so we'll ship it off to Mongoose middleware to do it each time for us.&lt;/p&gt;

&lt;p&gt;Shifting gears away from the stories a little, in my recent project we had a users schema that held references to organizations, projects, and tasks all of which were separate collections in their own right.&lt;/p&gt;

&lt;p&gt;Here's what our user schema looked like:  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var usersSchema = new Schema({  
  username: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true
  },
  organization: [{
    type: Schema.ObjectId,
    ref: 'Org'
  }],
  project_list: [{
    type: Schema.ObjectId,
    ref: 'Project'
  }],
  task_list: [{
    type: Schema.ObjectId,
    ref: 'Task'
  }]
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It would be nice, no matter when you grabbed a user from the DB, it had all of those fields automatically populated, right?&lt;/p&gt;

&lt;p&gt;On defining the model, you can hook into the Mongoose middleware, specifically the 'init' hook which will get fired whenever an existing model is grabbed from the DB.  Inside of the users' model definition, I added in this hook.  It makes use of the Mongoose Model's populate method.  You can pass a space delimited string of all the fields you want to populate.  Any time a user model is picked up, it will have each of those DB-ref fields filled out.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;db.usersSchema.pre('init', function(next, data) {  
  User.populate(data, {
    path: 'organization project_list task_list'
  }, function(err, user) {
    data = user;
    next();
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I found this solution to work quite nicely with what we were trying to achieve.  We maintained separate, highly related collections.  Each collection was easy to access and update, and there was only one source of truth for each entry.  We also got access to the convenience and intuitive structure of POJOs automatically built for us with every query!  A nice little solution that gave us the best of both worlds.&lt;/p&gt;</content:encoded></item><item><title>Getting a Written Transcript for a Youtube Video Using IBM Watson</title><description>&lt;p&gt;I will go through a quick script that will download audio from a Youtube video and then send it off to the IBM Watson speech to text service to get a written transcript.&lt;/p&gt;

&lt;p&gt;If you're the impatient type, here's the complete code. &lt;br&gt;
&lt;a href="https://github.com/alexzywiak/youtube-transcriber"&gt;youtube-transcriber&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set Up&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To illustrate, I'm going to&lt;/p&gt;</description><link>http://localhost:2368/getting-a-written-transcript-for-a-youtube-video-using-ibm-watson-2/</link><guid isPermaLink="false">14731786-1ffb-4b5d-a1b0-2e10b18f8cfd</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Thu, 10 Dec 2015 02:41:10 GMT</pubDate><content:encoded>&lt;p&gt;I will go through a quick script that will download audio from a Youtube video and then send it off to the IBM Watson speech to text service to get a written transcript.&lt;/p&gt;

&lt;p&gt;If you're the impatient type, here's the complete code. &lt;br&gt;
&lt;a href="https://github.com/alexzywiak/youtube-transcriber"&gt;youtube-transcriber&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set Up&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To illustrate, I'm going to create three files.  &lt;code&gt;youtube.js&lt;/code&gt; to handle downloading the audio file, &lt;code&gt;watson.js&lt;/code&gt; to get the transcription from Watson, and &lt;code&gt;index.js&lt;/code&gt; to tie them together.  There are a handful of modules we'll have to prepare, also.&lt;/p&gt;

&lt;p&gt;We're going to use &lt;a href="https://rg3.github.io/youtube-dl/"&gt;youtube-dl&lt;/a&gt; to handle getting the audio for us.  If you have &lt;code&gt;homebrew&lt;/code&gt;, install &lt;code&gt;youtube-dl&lt;/code&gt; by running:&lt;/p&gt;

&lt;pre&gt;brew install youtube-dl&lt;/pre&gt;

&lt;p&gt;We will have to do some audio processing as well.  &lt;code&gt;youtube-dl&lt;/code&gt; can make use of &lt;a href="https://www.ffmpeg.org/"&gt;ffmpeg&lt;/a&gt; to do all its auditory dirty work, so go ahead and install that, too.&lt;/p&gt;

&lt;pre&gt;brew install ffmpeg&lt;/pre&gt;

&lt;p&gt;While we're on the module train, let's prep all the necessary npm packages.&lt;/p&gt;

&lt;pre&gt;npm install bluebird watson-developer-cloud fluent-ffmpeg&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Downloading Audio from Youtube&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To download the audio, we will spawn a node child process to run &lt;code&gt;youtube-dl&lt;/code&gt;.The spawn process does all the work for us.  We pass the URL of the video we want, specify only to grab the audio, set the output to mp3, and set the file name.  I have the file named simply as &lt;code&gt;file.mp3&lt;/code&gt;, but it can be changed to whatever you need.  Check the &lt;a href="https://rg3.github.io/youtube-dl/"&gt;youtube-dl&lt;/a&gt; docs for more details.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// youtube.js
var spawn = require('child_process').spawn;  
var Promise = require('bluebird');  
var ffmpeg = require('fluent-ffmpeg');  
var path = require('path');

exports.getYouTubeAudio = function(videoId){  
    return new Promise(function(resolve, reject){
      // Install youtube_dl locally: brew install youtube-dl
    youtube_dl = spawn('youtube-dl', ['--extract-audio', '--audio-format', 'mp3', '-o', 'file.%(ext)s', "http://www.youtube.com/watch?v=" + videoId]);

    youtube_dl.stdout.on('data', function(data){
      console.log(data.toString());
    });

    youtube_dl.stderr.on('data', function(data){
      process.stderr.write(data);
    });

    // brew install ffmpeg
    youtube_dl.on('exit', function(){
      var mp3File = path.join(__dirname, 'file.mp3');
      var flacFile = path.join(__dirname, 'file.flac')
      ffmpeg(mp3File)
        .output(flacFile)
        .on('end', function(){
          resolve();
        })
        .on('error', function(err){
          reject(err);
        })
        .run();
    });
  });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, Watson takes &lt;code&gt;flac&lt;/code&gt; files, so we'll have to convert our &lt;code&gt;mp3&lt;/code&gt;.  We can use the &lt;code&gt;fluent-ffmpeg&lt;/code&gt; module to take care of this for us.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;    //youtube.js
    var ffmpeg = require('fluent-ffmpeg);
...
    youtube_dl.on('exit', function(){
      var mp3File = path.join(__dirname, 'file.mp3');
      var flacFile = path.join(__dirname, 'file.flac')
      ffmpeg(mp3File)
        .output(flacFile)
        .on('end', function(){
          resolve();
        })
        .on('error', function(err){
          reject(err);
        })
        .run();
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I've also used Bluebird as a promise library to resolve once the &lt;code&gt;ffmpeg&lt;/code&gt; conversion is complete, so that we can easily chain the download with our next script.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Getting a Transcript from Watson&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In order to use Watson, you need to head on over to IBM &lt;a href="http://www.ibm.com/cloud-computing/bluemix/?cm_mmc=search-gsn-_-branded-Bluemix-general-_-bmm%20%2Bblue%20%2Bmix%20blue%20mix-_-usa-bm-mkt-oww"&gt;Bluemix&lt;/a&gt; and sign up to get some creds. &lt;/p&gt;

&lt;p&gt;To use Watson in Node, the good folks at IBM were kind enough to create an &lt;a href="https://www.npmjs.com/package/watson-developer-cloud#speech-to-text"&gt;npm module&lt;/a&gt; for us.  So to get connected, include this code.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// watson.js
var watson = require('watson-developer-cloud');

var speech_to_text = watson.speech_to_text({  
  username: &amp;lt;bluemix username&amp;gt;,
  password: &amp;lt;bluemix password&amp;gt;,
  version: 'v1',
  url: 'https://stream.watsonplatform.net/speech-to-text/api',
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few ways to send and get the transcript from Watson.  I went for streaming as you can send larger files.  As the response is streamed back, we're going to build out a json object and then write it to a file when the transcription stream is done.&lt;/p&gt;

&lt;p&gt;This function will take in the path to the audio file we want to transcribe, &lt;code&gt;file.flac&lt;/code&gt; for our example, and will write the transcript to &lt;code&gt;transcript.json&lt;/code&gt;.  The &lt;code&gt;params&lt;/code&gt; option allows you to specify additional information you want Watson to include.  Here, I asked for timestamps for each word as well as to ignore silence by setting &lt;code&gt;continue&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.  If you only want the written transcript, you can stream the output directly into a &lt;code&gt;writeStream&lt;/code&gt; to a text file.  I opted for JSON because I wanted to get at the timestamp objects.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript "&gt;// watson.js
var watson = require('watson-developer-cloud');  
var fs = require('fs');  
var path = require('path');  
var Promise = require('bluebird');

var speech_to_text = watson.speech_to_text({  
  username: &amp;lt;bluemix username&amp;gt;,
  password: &amp;lt;bluemix password&amp;gt;,
  version: 'v1',
  url: 'https://stream.watsonplatform.net/speech-to-text/api',
});

exports.watsonSpeechToText = function(audioFile) {

  return new Promise(function(resolve, reject) {

    var params = {
      content_type: 'audio/flac',
      timestamps: true,
      continuous: true
    };

    var results = [];

    // create the stream
    var recognizeStream = speech_to_text.createRecognizeStream(params);

    // pipe in some audio
    fs.createReadStream(audioFile).pipe(recognizeStream);

    // listen for 'data' events for just the final text
    // listen for 'results' events to get the raw JSON with interim results, timings, etc.

    recognizeStream.setEncoding('utf8'); // to get strings instead of Buffers from `data` events

    recognizeStream.on('results', function(e) {
      if (e.results[0].final) {
        results.push(e);
      }
    });

    ['data', 'results', 'error', 'connection-close'].forEach(function(eventName) {
      recognizeStream.on(eventName, console.log.bind(console, eventName + ' event: '));
    });

    recognizeStream.on('error', function(err) {
      util.handleError('Error writing to transcript.json: ' + err);
    });

    recognizeStream.on('connection-close', function() {
        var transcriptFile = path.join(__dirname, 'transcript.json');

      fs.writeFile(transcriptFile, JSON.stringify(results), function(err) {
        if (err) {
          util.handleError(err);
        }
        resolve();
      });
    });
  });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All you need to do is chain these functions together and you will have all the transcripted goodness you would want!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Running the Show&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;index.js&lt;/code&gt; will combine our two modules and allow you to run them using the command line.  As it's set up here, run &lt;code&gt;node index.js transcribe &amp;lt;some video id&amp;gt;&lt;/code&gt; and you're up and running!&lt;/p&gt;

&lt;p&gt;Give this one a try: &lt;code&gt;node index.js transcribe I9VA-U69yaY&lt;/code&gt;  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// index.js
var watson = require('./watson');  
var youtube = require('./youtube');  
var path = require('path');

var flags = process.argv.slice(2);

if(flags[0] === 'transcribe'){  
    youtube.getYouTubeAudio(flags[1])
        .then(watson.watsonSpeechToText.bind(this, path.join(__dirname, 'file.flac')))
        .then(function(){
            console.log('Done transcribing video id: ' + flags[1]);
        });
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>Creating a MySpace Style Full Screen Search Using Angular Directives</title><description>&lt;p&gt;MySpace (yeah it still exists!) has a really cool UI search feature.  Just start typing and a slick full screen search interface pops up.  For a recent project we were building in Angular, we wanted to implement something similar.  Sounds like the perfect place for some directives!&lt;/p&gt;

&lt;p&gt;To create this&lt;/p&gt;</description><link>http://localhost:2368/creating-a-myspace-style-full-screen-search-using-angular-directives/</link><guid isPermaLink="false">822e46f0-d6ad-4cba-82c7-aa01e12153fb</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Sat, 05 Dec 2015 22:29:39 GMT</pubDate><content:encoded>&lt;p&gt;MySpace (yeah it still exists!) has a really cool UI search feature.  Just start typing and a slick full screen search interface pops up.  For a recent project we were building in Angular, we wanted to implement something similar.  Sounds like the perfect place for some directives!&lt;/p&gt;

&lt;p&gt;To create this feature, we're going to create two directives.  &lt;/p&gt;

&lt;p&gt;The first, &lt;code&gt;keyPressEvents&lt;/code&gt; will be work as a listener that will subscribe to all keypress events on the document and will use &lt;code&gt;$rootScope&lt;/code&gt; to broadcast those events to any other directives that care to listen.&lt;/p&gt;

&lt;p&gt;The second, &lt;code&gt;search&lt;/code&gt;, will subscribe to the $rootScope keypress events and will pull up a search interface.  It will also listen for specific keys, &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;esc&lt;/code&gt; to perform a search and to exit respectively.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Capturing Keypress Events&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Our first directive will be a general purpose event listener that will listen for any keypress events on the document, and will then use &lt;code&gt;$rootScope&lt;/code&gt; to broadcast them throughout the application.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;angular.module('recipes.keypress', [])  
  .directive('keypressEvents', [
    '$document',
    '$rootScope',
    function($document, $rootScope) {
      return {
        restrict: 'A',
        link: function() {
          $document.bind('keydown', function(e) {
            $rootScope.$broadcast('keypress', e);
            $rootScope.$broadcast('keypress:' + e.which, e);
          });
        }
      };
    }
  ]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On each keypress, this directive will broadcast two events on &lt;code&gt;$rootScope&lt;/code&gt;.  The first is &lt;code&gt;keypress&lt;/code&gt; which will pass the keypress event as a parameter.  The second, &lt;code&gt;keypress:&amp;lt;pressed key&amp;gt;&lt;/code&gt;, allows us to easily listen for specific keys being pressed.&lt;/p&gt;

&lt;p&gt;Attach the &lt;code&gt;keypressEvents&lt;/code&gt; as an attribute on the body element in your &lt;code&gt;index.html&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body keypress-events&amp;gt;  
  //Awesome Angular App
&amp;lt;/body&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Full Screen Search Directive&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;search&lt;/code&gt; directive is where most of the UI goodness will happen.  This directive will listen for the keypress events broadcast on &lt;code&gt;$rootScope&lt;/code&gt; the from &lt;code&gt;keypressEvents&lt;/code&gt; directive and will display a fullscreen search element capturing the user's query.  &lt;/p&gt;

&lt;p&gt;It will listen for the &lt;code&gt;enter&lt;/code&gt; key to execute the search. It will use &lt;code&gt;$rootScope&lt;/code&gt; to broadcast the search event and pass the query string as a parameter to any listeners you want to set up to deal process the search.  &lt;/p&gt;

&lt;p&gt;It will also listen for &lt;code&gt;esc&lt;/code&gt; to hide itself.  &lt;/p&gt;

&lt;p&gt;In case you want to disable it, like you need to catch user input without the search popping up and ruining everything, we will create another &lt;code&gt;$rootScope&lt;/code&gt; variable, &lt;code&gt;search&lt;/code&gt; which by default is set to &lt;code&gt;true&lt;/code&gt;.  If keyboard input is required outside of the search, the search can be disabled by setting &lt;code&gt;$rootScope.search = false&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;angular.module('recipes.search', [])  
  .directive('search', ['$rootScope', '$state', function($rootScope, $state) {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'app/directives/search/search.html',
      controller: 'SearchCtrl',
      link: function(scope, el, attr) {

        // Default search to true
        $rootScope.search = true;
        var searchbar = el.find('#searchtext');

        // Subscribe to $rootScope events from keypressEvents directive
        scope.$on('keypress', function(onEvent, keypressEvent) {
          // Disable searching if $rootScope.search is set to false anywhere in the app
          if ($rootScope.search) {

            // On escape
            if (keypressEvent.which === 27) {
              searchbar.val('').blur();
              el.fadeOut(200);
              // On enter
            } else if (keypressEvent.which === 13) {
              // Broadcast the search event on enter, clear the search input, and fade the search screen

              $rootScope.$broadcast('search', searchbar.val());
              searchbar.val('').blur();
              el.fadeOut(200);

            } else {
              if(!el.is(':visible')){
// Add in the first key the user presses              searchbar.val(String.fromCharCode(keypressEvent.which));
              }
              // Show the search input
              scope.key = String.fromCharCode(keypressEvent.which);
              searchbar.focus();
              el.fadeIn(200);
            }
          }
        });
      }
    };
  }]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The search bar doesn't actually do anything with the search other than broadcast it out into app-land, so to add some functionality you need to subscribe to it in any of your other directives or controllers.  To do so, make sure and inject the &lt;code&gt;$rootScope&lt;/code&gt; dependency Then add in the following subscription.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;$rootScope.$on('search', function(event, query){
  // Process Search
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this include a template html file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id="search"&amp;gt;  
    &amp;lt;form ng-model="searchCriteria" id="searchform"&amp;gt;
        &amp;lt;label id="label" for="searchtext"&amp;gt;search: &amp;lt;/label&amp;gt;
        &amp;lt;input id="searchtext" name="searchtext" type="text" /&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to add some CSS, which I won't go into here, to make it full screen.&lt;/p&gt;

&lt;p&gt;Add in the &lt;code&gt;&amp;lt;search&amp;gt;&amp;lt;/search&amp;gt;&lt;/code&gt; element on any page and you're good to go!&lt;/p&gt;</content:encoded></item><item><title>Setting up a Wikipedia Factory in Angular</title><description>&lt;p&gt;API's make your tiny little app look like a mother fuckin sorcerer.  With a few well placed $http calls, you can live the Dev dream and have all the data you want without actually having to go get it yourself.  To do that, I'm going to go through how to&lt;/p&gt;</description><link>http://localhost:2368/setting-up-a-wikipedia-factory-in-angular/</link><guid isPermaLink="false">f64974eb-adea-4e73-adba-c4ba56659240</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Sun, 15 Nov 2015 00:53:41 GMT</pubDate><content:encoded>&lt;p&gt;API's make your tiny little app look like a mother fuckin sorcerer.  With a few well placed $http calls, you can live the Dev dream and have all the data you want without actually having to go get it yourself.  To do that, I'm going to go through how to set up a basic factory in Angular to run some queries to Wikipedia that will grab an image and the article extract for a set of titles.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set up Factory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First, declare a factory onto an app module.  Our factory will expose one function to its subscribing controllers called &lt;code&gt;getWiki&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;angular.module('angularApp')  
  .factory('wikiFactory', function($http){

  var getWiki = function(title){};

  return {
    getWiki: getWiki
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Build our Query URL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next up we have to navigate the wilds of the Wiki API and create a url that will pull up our images and extract.  First, we add a variable defining the base Wiki API url. Then, we will define a helper function which will take an object and convert it into an appropriately parsed URL parameters string.  This will allow us to conveniently add in all our search parameters using object notation in our &lt;code&gt;getWiki&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;    var wikiUrl = "http://en.wikipedia.org/w/api.php?action=query&amp;amp;format=json&amp;amp;callback=JSON_CALLBACK";

    var buildQuery = function(obj) {
      var url = wikiUrl;
      for (var key in obj) {
        url += '&amp;amp;' + key + '=' + obj[key];
      }
      return url;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Run some $http&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;getWiki&lt;/code&gt; function will make use of the angular &lt;code&gt;$http&lt;/code&gt; module and promises to deal with all the async magic.  We will pass an object defining all of our search parameters, use the &lt;code&gt;buildQuery&lt;/code&gt; helper function to collate them into a searchable string, and then send off our request to Wikipedia.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note on CORS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To avoid Cross Origin issues, we'll set our method to &lt;a href="https://en.wikipedia.org/wiki/JSONP"&gt;jsonp&lt;/a&gt; so that everyone plays nice together.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  var getWiki = function(titlesArray) {
      var url = buildQuery({
        titles: titlesArray.join('|'),
        prop: "pageimages|extracts",
        pithumbsize: 500,
        redirects: true,
        exintro: true,
        explaintext: true,
      });

      return $http({
        url: url,
        method: 'jsonp'
      }).then(function(results) {
        return results.data;
      });
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will make a query for all titles contained in the passed in array.  It will grab an image of size 500, or closest, and the extract parsed into a string.  Redirects is set to &lt;code&gt;true&lt;/code&gt; so if the title leads to a redirect, the redirect article will be sent.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tie it All Together&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So toss that little factory in there and you're good to go querying Wikipedia to your app's heart's content!  Beware that the data that comes back is organized based on the Wiki page id, so you'll have to do a little digging to get at the good stuff.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;angular.module('angularApp')  
  .factory('wikiFactory', function($http) {

    var wikiUrl = "http://en.wikipedia.org/w/api.php?action=query&amp;amp;format=json&amp;amp;callback=JSON_CALLBACK";

    var buildQuery = function(obj) {
      var url = wikiUrl;
      for (var key in obj) {
        url += '&amp;amp;' + key + '=' + obj[key];
      }
      return url;
    };

    var getWiki = function(titles) {
      var url = buildQuery({
        titles: titles.join('|'),
        prop: "pageimages|extracts",
        pithumbsize: 500,
        redirects: true,
        exintro: true,
        explaintext: true,
      });

      return $http({
        url: url,
        method: 'jsonp'
      }).then(function(results) {
        return results.data;
      });
    };

    return {
      getWiki: getWiki
    }
  });
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>Growing a Trie in JS for Some Slick Word Searches</title><description>&lt;p&gt;A &lt;a href="https://en.wikipedia.org/wiki/Trie"&gt;trie&lt;/a&gt; is nifty little data structure that can be used to very quickly and efficiently check for the spelling of a word.  &lt;/p&gt;

&lt;p&gt;A little mind exercise:  Imagine you're playing a very high stakes game of Scrabble against Grandma and Aunt Helen and you just can't bear to be beaten&lt;/p&gt;</description><link>http://localhost:2368/growing-a-trie-in-js-for-some-slick-word-searches/</link><guid isPermaLink="false">3cfff344-8396-4b85-b5fb-44fe24621a59</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Wed, 04 Nov 2015 04:13:49 GMT</pubDate><content:encoded>&lt;p&gt;A &lt;a href="https://en.wikipedia.org/wiki/Trie"&gt;trie&lt;/a&gt; is nifty little data structure that can be used to very quickly and efficiently check for the spelling of a word.  &lt;/p&gt;

&lt;p&gt;A little mind exercise:  Imagine you're playing a very high stakes game of Scrabble against Grandma and Aunt Helen and you just can't bear to be beaten again.  So, you do what any other good Dev would do, and write a computer program to do the heavy lifting for you.  &lt;/p&gt;

&lt;p&gt;Assuming you have all the permutations of the letters passed into your program, how would you check which ones were valid super high scoring words?  Comparing each against a list of dictionary words would be prohibitively slow and Aunt Helen would quickly become suspicious.&lt;/p&gt;

&lt;p&gt;That's where the &lt;code&gt;trie&lt;/code&gt; structure comes in.  A trie is composed of linked nodes which each hold a value, in this case a letter, and links to &lt;em&gt;any subsequent letters that would continue to from a valid word&lt;/em&gt;. In this case, the nodes will also hold a property letting us know if that node represents the end of a valid word, so we know when to stop looking. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Essence of a Trie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For example, the word &lt;strong&gt;tea&lt;/strong&gt; (a paltry 3 points, I know) would be composed of four nodes.  The root node up at the top is the point of all departure.  It hold references to all the possible &lt;em&gt;first&lt;/em&gt; letters of any words (in the diagrams case, t, A and i).  To check if the word &lt;strong&gt;tea&lt;/strong&gt; exists in the list, we would first look at the root node for a reference to any &lt;strong&gt;t&lt;/strong&gt; child nodes.  In this case there is one, so we check the &lt;strong&gt;t&lt;/strong&gt; node for a reference to &lt;strong&gt;e&lt;/strong&gt;, the second letter in our word.  That exists, as does a subsequent reference to &lt;strong&gt;a&lt;/strong&gt;.  Once we reach the last letter in our word, we will have to check to see if the final node corresponds to an entire word.  If it does, we know we have a match!&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/10/trie.png" alt="Trie diagram courtesy of Wikipedia"&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Show Me the Code, Bro&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OK, that's some lovely CS101 fluffiness, but how do we do something with it.  JS can nicely model a Trie structure using Objects.&lt;/p&gt;

&lt;p&gt;The basic object will have a letter property, corresponding to the &lt;code&gt;letter&lt;/code&gt; that node represents, and an &lt;code&gt;isWord&lt;/code&gt; property which will be set to &lt;code&gt;true&lt;/code&gt; if that node represents the end of a complete word.  Letter also defaults to and empty string to represent the root node in the Trie.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javasript"&gt;var Trie = function(letter) {  
  this.letter = letter || '';
  this.isWord = false;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where it really gets good is inserting new words into our Trie structure.  To do that we'll add an insert method to the &lt;code&gt;Trie.prototype&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// Adds a new word into the prefix tree
Trie.prototype.insert = function(word) {  
  var currentNode = this;
  var newNode;
  var ch;
  // Loop through all the letters of the word to be inserted.
  for (var i = 0; i &amp;lt; word.length; i++) {
    ch = word.charAt(i);
    // Check if the current node already has a property corresponding to the next letter
    if (currentNode[ch]) {
      // If it does have that letter already
      // Move current node on to the next child node corresponding to next letter
      currentNode = currentNode[ch];
      // If Next letter node DOESN'T exists
    } else {
      // create a new child node for the next letter
      // move current node on to the new node
      newNode = new Trie(ch);
      currentNode[ch] = newNode;
      currentNode = newNode;
    }
    // When the last letter is reached, set the current node's 
    // isWord property to true to represent the end of a complete
    // word.
    if (i === word.length - 1) {
      currentNode.isWord = true;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method will take in a &lt;code&gt;word&lt;/code&gt; parameter and will insert it into our Trie.  To do that, it will loop over each letter in the new word, represented as &lt;code&gt;ch&lt;/code&gt;, moving down the trie as it goes.  To model the connections, we simply use properties on the &lt;code&gt;Trie&lt;/code&gt; object with the letter as the key name and the next node as the value.  &lt;/p&gt;

&lt;p&gt;Using the diagram above as an example, that root node would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;{ 
  t: Trie,
  A: Trie,
  i: Trie,
  isWord: false,
  letter: ''
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting at the root node as the first value for &lt;code&gt;currentNode&lt;/code&gt;, it will check if there is a property corresponding to the first letter in the word.  If that property already exists, we'll set it as &lt;code&gt;currentNode&lt;/code&gt; and move on to the next letter.  If it doesn't exist, we'll create a new &lt;code&gt;Trie&lt;/code&gt; object with its letter property set to &lt;code&gt;ch&lt;/code&gt;, set it as &lt;code&gt;currentNode&lt;/code&gt; and move on to the next letter.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;    if (currentNode[ch]) {
      // If it does have that letter already
      // Move current node on to the next child node corresponding to next letter
      currentNode = currentNode[ch];
      // If Next letter node DOESN'T exists
    } else {
      // create a new child node for the next letter
      // move current node on to the new node
      newNode = new Trie(ch);
      currentNode[ch] = newNode;
      currentNode = newNode;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we'll add a check to set the &lt;code&gt;isWord&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; when we've reached the last letter.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// When the last letter is reached, set the current node's 
    // isWord property to true to represent the end of a complete
    // word.
    if (i === word.length - 1) {
      currentNode.isWord = true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make use of the insert function, we'll create a new instance of a &lt;code&gt;Trie&lt;/code&gt;, which will represent our root node, and then we can drop in words to our heart's content.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var trie = new Trie();  
trie.insert('crepuscular');  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;insert&lt;/code&gt; method will allow us to build out a structure similar to the diagram above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What Goes in Must Come Out&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Great, we can add words, but how do we know what's in there?&lt;/p&gt;

&lt;p&gt;To search through the existing words, we'll need another method.  We'll create a &lt;code&gt;contains&lt;/code&gt; method which will take a string as an argument.  It will search through the trie and return a boolean value representing if the string is a word in the trie or not.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;Trie.prototype.contains = function(str) {  
  var currentNode = this;
  var ch;

  // Loop through each letter in the string
  for (var i = 0; i &amp;lt; str.length; i++) {
    ch = str.charAt(i);
    // Check if the current node has a link to that letter
    if (!currentNode[ch]) {
      // If it doesn't, str isn't a valid word so return false
      return false;
    } else {
      // If it is a valid letter, move on to the next node.
      currentNode = currentNode[ch];
    }
    // If we reach the end of the string and the current node
    // represents a complete word, return true.
    if (i === str.length - 1 &amp;amp;&amp;amp; currentNode.isWord) {
      return true;
    }
  }
  // If we reach the end of the string, but it's not a complete
  // word, return false.
  return false;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can check if our trie structure contains a given word.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var trie = new Trie();  
trie.insert('crepuscular');  
trie.insert('hirsute');  
trie.insert('cheese');

trie.contains('cheese') // ---&amp;gt; true  
trie.contains('chee'); // ---&amp;gt; false  
trie.contains('askldf'); // ---&amp;gt; really false  
trie.contains('tubular'); // ---&amp;gt; false because we didn't add it yet  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;What Next&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So we have trie, but we're not that much closer to having something that can help us school Grandma in Scrabble.  The trie is a necessary step though.  In order to find all possible scrabble words, we have to test all permutations of seven letters.  That's a lot of look ups! Although a trie needs a considerable amount of time to preprocess all the words in the dictionary, when that's complete we have the ability to check if a string is a valid word &lt;strong&gt;with constant time look up!&lt;/strong&gt;  Instead of looping through the entire dictionary to check each word, we only have to look at as many nodes as letters in the string.  &lt;/p&gt;

&lt;p&gt;Next up, I'll go over an algorithm that will find and test all combinations of letters in a Scrabble hand.&lt;/p&gt;</content:encoded></item><item><title>Modelling Collision Detection in D3 with tween functions.</title><description>&lt;p&gt;Despite being named after a terribly awkward developmental stage, &lt;code&gt;tween&lt;/code&gt; functions can let you do some really cool stuff in d3.&lt;/p&gt;

&lt;p&gt;The tween function is run on an element during a d3 transition.  It allows you to register a custom function that will be run at every increment between the&lt;/p&gt;</description><link>http://localhost:2368/modelling-collision-detection-in-d3/</link><guid isPermaLink="false">e66640a4-0304-4528-878f-81b962b6431c</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Sat, 31 Oct 2015 15:47:37 GMT</pubDate><content:encoded>&lt;p&gt;Despite being named after a terribly awkward developmental stage, &lt;code&gt;tween&lt;/code&gt; functions can let you do some really cool stuff in d3.&lt;/p&gt;

&lt;p&gt;The tween function is run on an element during a d3 transition.  It allows you to register a custom function that will be run at every increment between the two poles of that transition and get reference to the precise attributes of the element each step of the way.  &lt;/p&gt;

&lt;p&gt;I came across tween functions to model collision detection when I was trying to implement a rudimentary Asteroids clone.  For this example, I'll boil it down a little more, and use a custom tween function to determine when to randomly moving circles intersect each other.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set Up d3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To get things going we're going to set up the &lt;code&gt;svg&lt;/code&gt; element and append it.  We'll also add some data for d3 to join for some sweet circles.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  var svg = d3.select('#container')
    .append('svg')
    .attr('height', 600)
    .attr('width', 1000);

  var data = ['blue', 'purple'];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Set Up Animation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next up, we're going to set up a simple animation to have our circles bounce around between random points on the screen.  We'll chain the animations by calling &lt;code&gt;.each('end', move)&lt;/code&gt; to re-call the &lt;code&gt;move&lt;/code&gt; function when the original transition is completed.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  var move = function() {
    var circles = svg.selectAll('circle')
      .data(data);

    circles.enter()
      .append('circle')

    var circleAttrs = circles
      .transition()
      .duration(1000)
      .attr('cx', function(d) {
        return Math.floor(Math.random() * 1000);
      })
      .attr('cy', function(d) {
        return Math.floor(Math.random() * 600);
      })
      .attr('r', 100)
      .attr('fill', function(d) {
        return d;
      })
      .tween('collision', collisionDetection)
      .each('end', move);
  };

  move();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Enter Tween Function&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Notice right before the final call to &lt;code&gt;.each&lt;/code&gt;, we add our tween function.  The first argument is the name the tween function is registered for, and the second argument is a factory function that will return a function to be run on all the increments between the start and the end of the transition.&lt;/p&gt;

&lt;p&gt;The factory function passed to &lt;code&gt;tween&lt;/code&gt; must &lt;strong&gt;return a function&lt;/strong&gt;.  It's also possible to take advantage of the closure nature of the factory function to preserve and reference any information from the start of the transition.&lt;/p&gt;

&lt;p&gt;Our factory function, &lt;code&gt;collisionDetection&lt;/code&gt; will return a function that will grab all other present circles using &lt;code&gt;d3.select&lt;/code&gt;, and using some slick 8th grade Pythagorean algebra, determine the distance between our circle and any others.  If the calculated distance is less than the sum of their two radii, we'll consider them collided.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var collisionDetection = function() {  
    return function() {
      var thisCircle = d3.select(this);

      d3.select('circle').each(function() {
        var otherCircle = d3.select(this);

        if (thisCircle.datum() !== otherCircle.datum()) {

          dx = thisCircle.attr('cx') - otherCircle.attr('cx'),
            dy = thisCircle.attr('cy') - otherCircle.attr('cy'),
            distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

          if (distance &amp;lt; +thisCircle.attr('r') + +otherCircle.attr('r')) {
            collision(thisCircle, otherCircle);
          }
        }
      });
    };
  };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, on a collision it will call a collision function passing in the two offending circles.  Throw in a quick &lt;code&gt;console.log&lt;/code&gt; to see what's going on.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;  var collision = function(thisCircle, otherCircle) {
    console.log('Collision at: ' + thisCircle.attr('cx') + ',' + thisCircle.attr('cy'));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tween&lt;/code&gt; functions give you a lot of room to play around when using transitions in d3.  Check out the &lt;a href="https://github.com/mbostock/d3/wiki/Transitions#attrTween"&gt;documentation&lt;/a&gt; and make some sweet stuff.&lt;/p&gt;</content:encoded></item><item><title>Audio Visualiser Using D3</title><description>&lt;p&gt;D3 isn't just for squares with their pie charts and bar graphs anymore.  D3 can be totally Rock 'n Roll, man!  And to prove that to all you naysayers, we'll go ahead and build a sweet rockin' audio visualiser right in our browser.&lt;/p&gt;

&lt;p&gt;Or, if you prefer, cut to the&lt;/p&gt;</description><link>http://localhost:2368/audio-visualiser-using-d3/</link><guid isPermaLink="false">a9984624-d736-432f-8dc4-d0d584f213c1</guid><dc:creator>Alex Zywiak</dc:creator><pubDate>Sat, 24 Oct 2015 21:43:46 GMT</pubDate><content:encoded>&lt;p&gt;D3 isn't just for squares with their pie charts and bar graphs anymore.  D3 can be totally Rock 'n Roll, man!  And to prove that to all you naysayers, we'll go ahead and build a sweet rockin' audio visualiser right in our browser.&lt;/p&gt;

&lt;p&gt;Or, if you prefer, cut to the chase and check out the full code on Github &lt;a href="https://github.com/alexzywiak/d3-Audio-Visualiser"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set Up index.html&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To get at some tunes, I'm going to use an HTML5 &lt;code&gt;audio&lt;/code&gt; tag with &lt;code&gt;id=player&lt;/code&gt; right in &lt;code&gt;index.html&lt;/code&gt; and just source the audio from a local file.  We can also tack on a &lt;code&gt;div&lt;/code&gt; with and &lt;code&gt;id="visualiser"&lt;/code&gt; for housing our visualiser.  Make sure to load up &lt;code&gt;d3&lt;/code&gt; and &lt;code&gt;jQuery&lt;/code&gt; while you're at it too!  &lt;/p&gt;

&lt;p&gt;If you're using a local audio file, you need to set up a localhost server and not just open the html file directly from your browser. Without a local server, you'll get a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS"&gt;CORS Access Restriction&lt;/a&gt; error when you try and run the visualiser!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Grabbing the AudioContext()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next, we're going create an &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext"&gt;AudioContext&lt;/a&gt; object, &lt;code&gt;context&lt;/code&gt;, so we can get at all those sweet frequencies.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;$(function(){
    var context = new AudioContext();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Create an AnalyserNode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We'll use the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createAnalyser"&gt;createAnalyser&lt;/a&gt; method on the &lt;code&gt;context&lt;/code&gt; object to create an &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode"&gt;AnalyserNode&lt;/a&gt;, &lt;code&gt;analyser&lt;/code&gt;, that will provide us with the real time frequency data we're looking for.&lt;/p&gt;

&lt;p&gt;Then we'll set what essentially amounts to the resolution of our &lt;code&gt;analyser&lt;/code&gt; object by setting its &lt;code&gt;fftSize&lt;/code&gt; property.  The &lt;code&gt;fftSize&lt;/code&gt; must be a power of 2 for some mathematically magical reason. The higher the resolution, the sharper the visualiser, but we'll end up animating animating exponentially more elements which can take a toll.  I've found that 512 to 1024 is a good balance between resolution and performance, but feel free to play around with it and see what you can do.  &lt;/p&gt;

&lt;p&gt;Finally, we'll create a &lt;code&gt;frequencyData&lt;/code&gt; array which is what we'll ultimately pass as data to d3 to power our visualisation.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;$(function() {
    var context = new AudioContext();
    var analyser = context.createAnalyser();
    analyser.fftSize = 64;
    var frequencyData = new Uint8Array(analyser.frequencyBinCount);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Connect Our Analyser&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next up, we have to route our tunes through our &lt;code&gt;analyser&lt;/code&gt;.  Using &lt;code&gt;jQuery&lt;/code&gt;, we're going to grab the &lt;code&gt;audio&lt;/code&gt; HTML tag we're listening to.  We'll pass the &lt;code&gt;audio&lt;/code&gt; tag element to the &lt;code&gt;context.createMediaElementSource&lt;/code&gt; method  and set it as our &lt;code&gt;source&lt;/code&gt;.  That will allow us to get the frequency data.  We'll connect our &lt;code&gt;analyser&lt;/code&gt; to the audio &lt;code&gt;source&lt;/code&gt;, and then finally, connect our &lt;code&gt;analyser&lt;/code&gt; to &lt;code&gt;context.destination&lt;/code&gt;, in normal parlance, you speakers, so that we can once again hear the music. Check out the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode"&gt;AnaylserNode&lt;/a&gt; and &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext"&gt;AudioContext&lt;/a&gt; docs for more info on what ever the hell's going on here.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;$("#player").bind('canplay', function() {
        var source = context.createMediaElementSource(this);
        source.connect(analyser);
        analyser.connect(context.destination);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our &lt;code&gt;analyser&lt;/code&gt; is all wired up to report back to us with real time info on what's playing.  To get an updated array of the frequency values, all we need to do is run &lt;code&gt;analyser.getByteFrequencyData(frequencyData)&lt;/code&gt; and the &lt;code&gt;frequencyData&lt;/code&gt; array we declared earlier, will get updated. &lt;/p&gt;

&lt;p&gt;To check it out, run a little &lt;code&gt;console.log&lt;/code&gt; action.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;setInterval(function(){  
  analyser.getByteFrequencyData(frequencyData);
  console.log(frequencyData)
}, 500);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the music starts playing, you should see all kinds of numbers dancing around in the console.  Unfortunately, that's only exciting for us geeky dev types.  We'll have to up our game to get the groupies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Visualise It&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A constantly changing array of numbers!  D3 is all over that!  Let's set up an &lt;code&gt;svg&lt;/code&gt; element to hold our sweet visuals.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var width = 800,  
        height = 600,
        barPadding = 0;

    var svg = d3.select('#visualiser')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We'll create an ever so basic bar graph in d3 bound to the frequency information.  This visualiser is as basic as they get, but d3 has so much awesomeness, your imagination is the limit.  &lt;/p&gt;

&lt;p&gt;Since we're going to be continuously updating our graph with the real time frequency data, we'll wrap drawing the graph in an &lt;code&gt;update&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;    var update = function(data) {

        rect = svg.selectAll('rect')
            .data(data)

        rect.enter().append('rect');

        rect.attr('width', function() {
                return width / data.length - barPadding;
            })
            .attr('height', function(d) {
                return d * 1000;
            })
            .attr('x', function(d, i) {
                return i * width / data.length;
            })
            .attr('y', function(d) {
                return height - d;
            })
            .attr('fill', function(d) {
                return "rgb(0, 0, " + (d * 10) + ")";
            });
    };

update(frequencyData);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, we'll make use of &lt;code&gt;d3.timer()&lt;/code&gt; to run continuously run our animation.  We also have to make sure and call &lt;code&gt;analyser.getByteFrequencyData(frequencyData)&lt;/code&gt; so that we get real time audio data.  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;d3.timer(function() {  
        analyser.getByteFrequencyData(frequencyData);
        update(frequencyData);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, you only have one more question to answer.  Are you ready to Rock?  &lt;/p&gt;

&lt;p&gt;I'm such a nerd...&lt;/p&gt;

&lt;p&gt;Full code up on &lt;a href="https://github.com/alexzywiak/d3-Audio-Visualiser"&gt;Git&lt;/a&gt;.&lt;/p&gt;</content:encoded></item></channel></rss>